<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from localhost/dotclear/index.php?archive by HTTrack Website Copier/3.x [XR&CO'2010], Sun, 27 Jan 2013 10:35:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="ROBOTS" content="INDEX, FOLLOW" />
  
  <title>Archives - DisPerSE - persistent structures identification</title>
  <meta name="copyright" content="sousbie" />
  <meta name="author" content="thierry sousbie" />
  <meta name="date" scheme="W3CDTF" content="2013-01-27T10:34:14+01:00" />
  
  <link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />
  <meta name="dc.title" lang="en" content="Archives - DisPerSE - persistent structures identification" />
  <meta name="dc.language" content="en" />
  <meta name="dc.publisher" content="thierry sousbie" />
  <meta name="dc.rights" content="sousbie" />
  <meta name="dc.date" scheme="W3CDTF" content="2013-01-27T10:34:14+01:00" />
  <meta name="dc.type" content="text" />
  <meta name="dc.format" content="text/html" />
  
  <link rel="top" href="indexd41d.html?" title="Home" />
  
      <link rel="chapter" href="index2f57.html?archive/3100/05" title="May 3100" />
      <link rel="chapter" href="index3586.html?archive/3000/05" title="May 3000" />
      <link rel="chapter" href="indexdf9e.html?archive/2430/01" title="January 2430" />
      <link rel="chapter" href="indexafae.html?archive/2426/01" title="January 2426" />
      <link rel="chapter" href="indexc0a5.html?archive/2425/05" title="May 2425" />
      <link rel="chapter" href="index5632.html?archive/2420/05" title="May 2420" />
      <link rel="chapter" href="index8728.html?archive/2320/05" title="May 2320" />
      <link rel="chapter" href="indexf052.html?archive/2310/05" title="May 2310" />
      <link rel="chapter" href="indexf343.html?archive/2305/05" title="May 2305" />
      <link rel="chapter" href="index6cc2.html?archive/2260/05" title="May 2260" />
      <link rel="chapter" href="index55cd.html?archive/2250/05" title="May 2250" />
      <link rel="chapter" href="index1d37.html?archive/2240/05" title="May 2240" />
      <link rel="chapter" href="index2a13.html?archive/2230/05" title="May 2230" />
      <link rel="chapter" href="indexa16a.html?archive/2220/05" title="May 2220" />
      <link rel="chapter" href="index5b9e.html?archive/2210/05" title="May 2210" />
      <link rel="chapter" href="indexe2b7.html?archive/2170/05" title="May 2170" />
      <link rel="chapter" href="index2358.html?archive/2160/06" title="June 2160" />
      <link rel="chapter" href="index0dd1.html?archive/2160/05" title="May 2160" />
      <link rel="chapter" href="index00a4.html?archive/2155/05" title="May 2155" />
      <link rel="chapter" href="indexd7fe.html?archive/2150/05" title="May 2150" />
      <link rel="chapter" href="index5abb.html?archive/2102/05" title="May 2102" />
      <link rel="chapter" href="indexe37e.html?archive/2101/05" title="May 2101" />
      <link rel="chapter" href="indexdda5.html?archive/2001/05" title="May 2001" />
    
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="../images/index4ca3.php?feed/atom" />
  
  <link rel="shortcut icon" href="../images/favicon.ico" />

<style type="text/css" media="screen">
@import url(../images/style.css);
</style>
<style type="text/css" media="print">
@import url(../images/print.css);
</style>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37686840-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>

<body class="dc-archive">
<div id="page">
<div id="top">
<!--
<h1><span><a href="http://localhost/dotclear/index.php?">DisPerSE - persistent structures identification</a></span></h1>
 -->

  </div>

<p id="prelude">
<a href="indexd41d.html?">Home</a> |
<a href="index888d.html?archive">Show all</a>
</p>

<!--
<ul id="nav-box">
2.
<li><a href="http://localhost/dotclear/index.php?">Accueil</a></li>
3.
<li><a href="http://localhost/dotclear/index.php?archive" title="Liste des mois de publication">Archives</a></li>
4.
<li><a href="http://localhost/dotclear/index.php?contact" title="Formulaire de contact">Me contacter</a></li>
5.
</ul>
 -->

<div id="wrapper">

<div id="main">

<h1 class="title">DisPerSE</h1>
<h2 class="subtitle">Automatic identification of persistent structures</h2>
<h2 class="subtitle">for cosmological and hopefully more useful applications.</h2>
</br>
<div id="content">
  
    
    <h2 class="post-title">
      <a href="index1694.html?category/Download">Download</a>
    </h2>
   
    
      <div id="p3" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index8e22.html?post/Download">Latest version</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="indexba87.html?category/Install">Install</a>
    </h2>
   
    
      <div id="p5" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexfe94.html?post/Requirements">Requirements</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p6" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index1670.html?post/Compiling">Compiling</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="index3c4a.html?category/Overview">Overview</a>
    </h2>
   
    
      <div id="p7" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index09c8.html?post/General-overview">Purpose</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p24" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index6458.html?post/Examples-of-applications">Examples of applications</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p20" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index1f6e.html?post/general-concepts">General concepts of Morse theory</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p40" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexd3dd.html?post/Persistence-and-simplification">Persistence and simplification</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="index4559.html?category/Terminology">Terminology</a>
    </h2>
   
    
      <div id="p21" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index959e.html?post/definitions">Definitions</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="index4f3e.html?category/Manual">Manual</a>
    </h2>
   
    
      <div id="p9" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index4656.html?post/mse">mse</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p10" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index490e.html?post/Usage">delaunay_nD</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p11" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index8707.html?post/pdview">pdview</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p12" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index25e8.html?post/netconv">netconv</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p13" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index6160.html?post/skelconv">skelconv</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p14" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexf1b8.html?post/fieldconv">fieldconv</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="index55a0.html?category/Quick-start">Tutorial</a>
    </h2>
   
    
      <div id="p41" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index38d8.html?post/regular-grid-%3A-filaments">Persistence diagrams and filaments</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p18" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index2d20.html?post/Example-1">Point sample: 2D voids and filaments</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p19" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexf6f1.html?post/Example-2">Point sample: 3D walls and filaments</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="index3333.html?category/Skeleton-I-O">Skeleton data</a>
    </h2>
   
    
      <div id="p16" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index661f.html?post/skeleton-formats">Skeleton files</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p25" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexf83e.html?post/NDskl-format">NDskl format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p26" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexbea5.html?post/NDskl_ascii-format">NDskl_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p27" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexfe47.html?post/segs_ascii-format">segs_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p28" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index083b.html?post/crits_ascii-format">crits_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p29" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexb3eb.html?post/vtk-formats">vtk skeleton formats</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="indexe2a5.html?category/Network-I-O">Network data</a>
    </h2>
   
    
      <div id="p15" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index9cca.html?post/networks">Network files</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p30" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexceff.html?post/NDnet-format">NDnet format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p31" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexd2e2.html?post/NDnet_ascii-format">NDnet_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p32" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexda8a.html?post/ply-format">ply format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p33" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexe8f9.html?post/vtk-network-format">vtk network format</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="indexc777.html?category/Field-I-O">Field data</a>
    </h2>
   
    
      <div id="p17" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexa0c1.html?post/field-formats">Field files</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p34" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index16de.html?post/NDfield-format">NDfield format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p35" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexd473.html?post/NDfield_ascii-format">NDfield_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p36" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index7327.html?post/FITS-format">FITS format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p37" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index744c.html?post/survey_ascii-format">survey_ascii format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p38" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexb2ad.html?post/SDL-image">SDL-image format</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p39" class="post odd " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="indexd991.html?post/vtk-field-format">vtk field format</a>
	</h2>
	<!--
				-->
      </div>
        
    <h2 class="post-title">
      <a href="indexdc31.html?category/References">Contact &amp; References</a>
    </h2>
   
    
      <div id="p22" class="post odd first" lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index5399.html?post/Contact">Contact</a>
	</h2>
	<!--
				-->
      </div>
    
      <div id="p23" class="post  " lang="en" xml:lang="en">
	
	<h2>
	  &#187;
	  <a href="index3876.html?post/References">References</a>
	</h2>
	<!--
				-->
      </div>
      </br></br></br>
   
<div class="content-inner">
 

 <h2 class="category-title">
 <a href="index1694.html?category/Download">Download</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index8e22.html?post/Download">Latest version</a>
   </h2>
      <div class="post-content"><p>This program is distributed freely for non-commercial use, however, we ask users to kindly cite DisPerSE as appropriately as possible in their papers, in particular by referencing the following articles (<a href="http://adsabs.harvard.edu/abs/2011MNRAS.414..350S" title="A">Sousbie 2011</a> and <a href="http://adsabs.harvard.edu/abs/2011MNRAS.414..384S" title="B">Sousbie &amp; al. 2011</a>):
<br />
<br /></p>

<pre>@ARTICLE{2011MNRAS.414..350S,
author = {{Sousbie}, T.},
title = "{The persistent cosmic web and its filamentary structure - I. Theory and implementation}",
journal = {\mnras},
archivePrefix = "arXiv",
eprint = {1009.4015},
primaryClass = "astro-ph.CO",
keywords = {methods: data analysis, methods: numerical, galaxies: formation, galaxies: kinematics and dynamics, cosmology: observations, large-scale structure of Universe},
year = 2011,
month = jun,
volume = 414,
pages = {350-383},
doi = {10.1111/j.1365-2966.2011.18394.x},
adsurl = {http://adsabs.harvard.edu/abs/2011MNRAS.414..350S},
adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@ARTICLE{2011MNRAS.414..384S,
author = {{Sousbie}, T. and {Pichon}, C. and {Kawahara}, H.},
title = "{The persistent cosmic web and its filamentary structure - II. Illustrations}",
journal = {\mnras},
archivePrefix = "arXiv",
eprint = {1009.4014},
primaryClass = "astro-ph.CO",
keywords = {methods: data analysis, galaxies: formation, galaxies: kinematics and dynamics, cosmology: observations, dark matter, large-scale structure of Universe},
year = 2011,
month = jun,
volume = 414,
pages = {384-403},
doi = {10.1111/j.1365-2966.2011.18395.x},
adsurl = {http://adsabs.harvard.edu/abs/2011MNRAS.414..384S},
adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}</pre>

<p><br />
<br /></p>


<p>You can download the latest version of the source code here (V0.9.22) : <a href="disperse_latest.tar.html" title="disperse_latest">disperse_latest.tar.gz</a>
<br />
<br /></p></div>
   

  

 <h2 class="category-title">
 <a href="indexba87.html?category/Install">Install</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="indexfe94.html?post/Requirements">Requirements</a>
   </h2>
      <div class="post-content"><div>The following libraries/programs are required:&nbsp;</div>
<br />
<ul>
<li>Cmake 2.6.3+</li>
<li>GSL</li>
</ul>
<br />
<br />
<div>The following libraries are optional:&nbsp;</div>
<br />
<ul>
<li>CGAL 3.7+ (for delaunay)</li>
<li>CFitsIO  (for reading FITS)</li>
<li>SDL/SDL-image (for loading jpg,bmp,...)</li>
<li>mathGL 1.10 (for visualizing persistence diagrams with pdview)</li>
<li>   -> A compatible version of the library is included in the 'external/'</li>
<li>      directory starting from disperse v0.9.22</li>
<li>Qt4 (for visualizing persistence diagrams with pdview)</li>
</ul>
<br />
<br />
<div><ins>NOTE:</ins> gcc v4.3.3+ is required for multithreading to be enabled.</div></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index1670.html?post/Compiling">Compiling</a>
   </h2>
      <div class="post-content">Go to the <q>${DISPERSE_SRC}/build</q> directory and type:<div>&nbsp;
<div style="text-align: center; border: 1px dotted gray;">cmake ../</div>
<br />This will check the configuration and generate the Makefile. Read the output to know which library were found, which were not, and how to specify their path (option <q>-DLIBNAME_DIR=path/to/library/</q> where {LIBNAME} may be QT,GSL,SDL,MATHGL or CGAL).</div><div>The default install path is "${DISPERSE_SRC}", but it can be changed using option <q>-DCMAKE_INSTALL_PREFIX=PATH/TO/INSTALL/DIR</q>.<br />Then just compile and install with:</div><div><br /><div style="text-align: center; border: 1px dotted gray;">make install -j N</div><br />where N is the number of processors to be used for compilation. One to seven executables should be created in <q>${DISPERSE_SRC}/bin</q> (or <q>${CMAKE_INSTALL_PREFIX}/bin</q> if set), depending on which libraries were found:&nbsp;<div><br />
<ul>
<li><a href="index4656.html?post/mse">mse</a></li>
<li><a href="index490e.html?post/Usage">delaunay_2D</a> (Optionnal)</li>
<li><a href="index490e.html?post/Usage">delaunay_3D</a> (Optionnal)</li>
<li><a href="index8707.html?post/pdview">pdview</a> (Optionnal)</li>
<li><a href="index6160.html?post/skelconv">skelconv</a></li>
<li><a href="index25e8.html?post/netconv">netconv</a></li>
<li><a href="indexf1b8.html?post/fieldconv">fieldconv</a></li>
</ul>
</div></div></div>
   

  

 <h2 class="category-title">
 <a href="index3c4a.html?category/Overview">Overview</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index09c8.html?post/General-overview">Purpose</a>
   </h2>
      <div class="post-content"><p>DisPerSE stands for <q>Discrete Persistent Structures Extractor</q> and its main purpose is to identify persistent topological features such as peaks, voids, walls and in particular filamentary structures within sampled distributions in 2D, 3D, and possibly more ...
<br />
<br />
Although it was initially developed with cosmology in mind (for the study of the properties of filamentary structures in the so called comic web of galaxy distribution over large scales in the Universe), the present version is quite versatile and should be useful for any application where a robust structure identification is required, for segmentation or for studying the topology of sampled functions (like computing persistent Betti numbers for instance).
<br />
<br />
DisPerSE is able to deal directly with noisy datasets using the concept of persistence (a measure of the robustness of topological features) and can work indifferently on many kinds of cell complex (such as structured and unstructured grids, 2D manifolds embedded within a 3D space, discrete point samples using delaunay tesselation, Healpix tesselations of the sphere, ...). The only constraint is that the distribution must be defined over a manifold, possibly with boundaries.
<br />
<br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index6458.html?post/Examples-of-applications">Examples of applications</a>
   </h2>
      <div class="post-content"><p>Here are a few examples of what DisPerSE can do (hover the cursor over the pictures for a short description) :
<br />
<br />
<img src="../images/.simu2d_filter2-b_m.jpg" alt="cosmic web" style="float:left; margin: 0 1em 1em 0;" title="Slice of a discretely sampled dark matter distribution in a numerical simulation of a 50Mpc chunk of the Universe. The filamentary structure of the cosmic web is clearly visible." />
<img src="../images/.simu2d_filter2-a5_m.jpg" alt="filamentary structures" style="float:right; margin: 0 0 1em 1em;" title="Identified filamentary structure and corresponding critical points (maxima in red, minima in blue and saddle points in yellow) " />
<br />
<br />
<img src="../images/.simu2d_filter-b_m.jpg" alt="zoom" style="float:left; margin: 0 1em 1em 0;" title="Zoom on a clump, the color corresponds to the density computed by DTFE" />
<img src="../images/.simu2d_filter-a5_m.jpg" alt="filaments connecting on a dark matter halo" style="float:right; margin: 0 0 1em 1em;" title="Persistent filaments connecting to a clump, note how maxima (red triangles) correctly identify bound structures" />
<br />
<br />
<img src="../images/cmb_skl_small.png" alt="CMB filaments" style="display:block; margin:0 auto;" title=" Filamentary structures in the cosmic microwave background (CMB). Structures were directly identified over the Healpix tessellation of the sphere" />
<br />
<br />
<img src="../images/.f3_simu250_large_simu_void_skel_crit_m.jpg" alt="" style="float:left; margin: 0 1em 1em 0;" title="Filamentary structures and a void (lower right) identified in the simulated distribution of dark matter. Structures where identified over the full 3D distribution, but only a 20Mpc thick slice is shown for convenience." />
<img src="../images/.f3_simu250z_void_simu_m.jpg" alt="" style="float:left; margin: 0 1em 1em 0;" title="Zoom on the void (i.e. low density region). Color corresponds to the density on the surface of the void." />
<br />
<br />
<img src="../images/herschel_fil.png" alt="herschel_fil.png" style="display:block; margin:0 auto;" title=" Star forming regions in the interstellar medium as observed by HERSCHEL." /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index1f6e.html?post/general-concepts">General concepts of Morse theory</a>
   </h2>
      <div class="post-content"><p>In DisPerSE, structures are identified as components of the Morse-Smale complex of an input function defined over a - possibly bounded - manifold. The Morse-Smale complex of a real valued so-called Morse function is a construction of Morse theory which captures the relationship between the gradient of the function, its topology, and the topology of the manifold it is defined over.
<br />
<br /></p>
<figure style="text-align:center;font-family:times;color:rgb(32,32,32);font-size:0.9em;">
Figure 1: the Morse-Smale complex</br>
<img src="../images/morse_illustration.jpg" alt="Blah"/><br>
<legend style="text-align:justify;font-family:times;color:rgb(32,32,32);font-size:1em;line-height:90%;margin:0px 20px 0px 20px;">
<i style="font-size:0.9em;">Upper left:</i> critical points (minima, saddle points and maxima pictured as blue, green and red disks), and three integral lines (pink curves) of a Morse function. Black arrows show the gradient of that function.
<i style="font-size:0.9em;">Upper right:</i> ascending 2-manifolds : the set of points belonging to integral lines whose destination is the same minimum (critical point of index 0).
<i style="font-size:0.9em;">Lower left:</i> descending 2-manifolds : the set of points belonging to integral lines whose origin is the same maximum (critical point of index 2).
<i style="font-size:0.9em;">Lower right:</i> the Morse-Smale complex : a natural tesselation of space into cells induced by the gradient fo the function. Each cell is the set of points belonging to integral lines whose origin and destination are identical (i.e. each cell is the intersection of an ascending and a descending manifold). The purple region is a 2-cell: intersection of an ascending and a descending 2-manifold (red and blue regions) where all field lines have the same orgin and destination (a minimum and a maxium). The yellow curve is a 1-cell (also called an arc): the intersection of and ascending 2-manifold (blue region) and a descending 1-manifolds (green+yellow curves, originating from the same saddle point).
</legend>
</figure>


<p><br />
<br />
Two central notions in Morse theory are that of <em>critical point</em> and <em>integral line</em> (also called <em>field line</em>) : (see the upper left frame of figure 1)
<br />
<br /></p>
<ul>
<li>-<strong>Critical points</strong> are the discrete set of points where the gradient of the function is null. For a function defined over a 2D space, there are three types of critical points (4 in 3D, ...), classified by their critical index. In 2D, minima have a critical index of 0, saddle points have a critical index of 1 and maxima have a critical index of 2. In 3D and more, different types of saddle points exist, one for each non extremal critical index.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>Integral lines</strong> are curves tangent to the gradient field in every point. There exist exactly one integral line going through every non critical point of the domain of definition, and gradient lines must start and end at critical points (i.e. where the gradient is null).</li>
</ul>
<p><br />
Because integral lines cover all space (there is exactly one critical line going through every point of space) and their extremities are critical points, they induce a tessellation of space into regions called ascending (resp. descending) <em>k-manifolds</em> where all the field lines originate (respectively lead) from the same critical point (see ascending and descending 2-manifolds on figure 1, upper right and lower left panels). The number of dimensions <em>k</em> of the regions spanned by a k-manifold depend directly on the critical index of the corresponding critical point: descending k-manifolds originate from critical points of critical index <em>k</em> while the critical index is <em>N-k</em> for ascending manifolds, with <em>N</em> the dimension of space.
<br />
<br />
The set of all ascending (or descending) manifolds is called the <em>Morse complex</em> of the function. The <em>Morse-Smale complex</em> is an extension of this concept: the tessellation of space into regions called <em>p-cells</em> where all the integral lines have the same origin and destination (see figure 1, lower right frame). Each p-cell of the Morse-Smale complex is the intersection of an ascending and a descending manifold and the Morse-Smale complex itself is a natural tessellation of space induced by the gradient of the function. Figure 2 below illustrates how components of the Morse-Smale complex can be used to identify structures in a 3D distribution.
<br />
<br /></p>
<figure style="text-align:center;font-family:times;color:rgb(32,32,32);font-size:0.9em;">
Figure 2: 3D structures identified as component of the Morse-Smale complex
<img src="../images/structures_as_manifolds.jpg" alt="Blah"/><br>
<legend style="text-align:justify;font-family:times;color:rgb(32,32,32);font-size:1em;line-height:90%;margin:0px 20px 0px 20px;">
<i style="font-size:0.9em;">Upper left:</i> Density distribution of dark matter in a chunk of the Universe represented by tracer particles from a N-Body cosmological simulation.
<i style="font-size:0.9em;">Upper right:</i> Ascending 3-manifolds tracing the voids
<i style="font-size:0.9em;">Lower left:</i> Ascending 2-manifolds tracing the walls
<i style="font-size:0.9em;">Lower right:</i> The set of arcs with one maximum at their extremity, also called upper skeleton, tracing the filamentary structures. The maxima, not represented here, identify dark matter halos onto which filaments plug.
</legend>
</figure>


<p><br />
<br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexd3dd.html?post/Persistence-and-simplification">Persistence and simplification</a>
   </h2>
      <div class="post-content"><p>Persistence itself is a relatively simple but powerful concept. To study the topology of a function, one can measure how the topology of its excursion sets (i.e. the set of points with value higher than a given threshold) evolves when the threshold is continuously and monotonically changing. Whenever the threshold crosses the value of a critical point, the topology of the excursion change. Supposing that the threshold is sweeping the values of a 1D function from high to low, whenever it crosses the value of a maximum, a new component appears in the excursion, while two components merge (i.e. one is destroyed) whenever the threshold crosses the value of a minimum. This concept can be extended to higher dimensions (i.e. creation/destruction of hole, spherical shells, ....) and in general, whenever a topological component is created at a critical point, the critical point is labeled positive, while it is labeled negative if it destroys a topological component. Using this definition, topological components of a function can be represented by pairs of positive and negative critical points called persistence pairs. The absolute difference of the value of the critical points in a pair is called its persistence : it represents the lifetime of the corresponding topological component within the excursion set.
<br />
<br /></p>
<figure style="text-align:center;font-family:times;color:rgb(32,32,32);font-size:0.9em;">
Figure 1: Persistence pairs</br>
<img src="../images/persistence1d.png" alt="Blah"/><br>
<legend style="text-align:justify;font-family:times;color:rgb(32,32,32);font-size:1em;line-height:90%;margin:0px 20px 0px 20px;">
<i style="font-size:0.9em;">Upper part:</i> Two functions with identical topology (i.e. two peaks).
<i style="font-size:0.9em;">Lower part:</i> Changes in topology of excursion sets (sets of point with value lower than a decreasing threshold, see main text above). In 1D, new components are created at maxima and destroyed at minima. Two persistence pairs represented by green lines account for the two peaks in each function. The length of the green lines corresponds to the persistence of the pairs, which correctly accounts for the the fact that A has a small bump on the top of a peak (one high and one low persistence pair), while B has two peaks (two high persistence pairs).
</legend>
</figure>


<p><br />
<br />
The concept of persistence is powerful because it yields a simple way to measure how robust topological components are to local modifications of a function values. Indeed, noise can only affect a function's topology by creating or destroying topological components of persistence lower that its local amplitude. Therefore, it suffice to know the amplitude of noise to decide which components certainly belong to an underlying function and which may have been affected (i.e. created or destroyed) by noise. In DisPerSE, a persistence threshold can be specified (see options <em>-nsig</em> and <em>-cut</em> of <a href="index4656.html?post/mse">mse</a>) to remove topological components with persistence lower than the threshold and therefore filter noise from the Morse-Smale complex (see figure 2 below).
<br />
<br /></p>
<figure style="text-align:center;font-family:times;color:rgb(32,32,32);font-size:0.9em;">
Figure 1: Morse-smale complexsimplification</br>
<img src="../images/persistence_simp2d.jpg" alt="Blah"/><br>
<legend style="text-align:justify;font-family:times;color:rgb(32,32,32);font-size:1em;line-height:90%;margin:0px 20px 0px 20px;">
Simplification of a low persistence pair (formed by maximum 19 and saddle point 18). Disks represent critical points (minima, saddle-points and maxima in blue, green and red respectively) and black lines show the arcs of the Morse-Smale complex.
</legend>
</figure>


<p><br />
<br />
A very useful way to set the persistence threshold is to plot a persistence diagram, in which all the persistence pairs are represented by points with coordinates the value at the critical points in the pair (see option <em>-interactive</em> of <a href="index4656.html?post/mse">mse</a> or see <a href="index8707.html?post/pdview">pdview</a> and read the <em>tutorial</em> section to learn how to compute and use persistence diagrams).</p></div>
   

  

 <h2 class="category-title">
 <a href="index4559.html?category/Terminology">Terminology</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index959e.html?post/definitions">Definitions</a>
   </h2>
      <div class="post-content"><p>In DisPerSE, the different types of cells that compose the <a href="index1f6e.html?post/general-concepts">Morse-Smale complex</a> are used to identify different types of structures. In this document, we adopt the following terminology:
<br />
<br /></p>
<ul>
<li>- <ins>A <strong>critical point</strong></ins><br /> is a point where the gradient is null. In N dimensional space, there are N types of critical point, characterized by a critical index.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>maximum</strong></ins><br /> is a critical point of critical index N in an N dimensional space.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>minimum</strong></ins><br /> is a critical point of critical index 0.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>k-saddle point</strong></ins><br /> is a critical point of critical index k that is neither a minimum nor a maximum.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>d-simplex</strong></ins><br /> is the most simple geometrical figure in <em>d</em> dimensions and consists of <em>d+1</em> points linked together (i.e a point, segment, triangle, tetrahedron ... for d=0,1,2,3,...). In DisPerSE, space is decomposed into d-simplices and each critical point is associated to a given <em>d</em>-simplex (by default, maxima are 0-simplices, saddle-points are 1-simplices, ...).</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>persistence pair</strong></ins><br /> is a pair of critical points with critical index difference of 1. A persistence pair represents a topological component of the function. More details <a href="indexd3dd.html?post/Persistence-and-simplification">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins> <strong>Persistence</strong></ins><br /> is defined as the difference (or ratio) of the value at the two critical points in a persistence pair. Persistence is always positive and represents the importance of the topological feature defined by the persistence pair : low persistence pairs are sensible to changes in the value of the function, and the corresponding critical points are easily destroyed, even by small perturbations, while high persistence pairs are robust. Removing low persistence pairs from the <a href="index1f6e.html?post/general-concepts">Morse-Smale complex</a> is a good way to filter noise and/or non-meaningfull structures. More details <a href="indexd3dd.html?post/Persistence-and-simplification">here</a>.</li>
</ul>
<p><br /><a name="robustness"></a></p>
<ul>
<li>- <ins><strong>Robustness</strong></ins><br /> is a local measure of how contrasted the critical points and filaments are with respect to their background. In a sense, robustness is a continuous version of persistence which extends to filaments (persistence applies to pairs of critical points only). What we call robustness here is actually an improved version of the <em>separatrix persistence</em> described in <em>Weinkauf, T. and Gunther, D., 2009</em>. See options <em><a href="index6160.html?post/skelconv#trim">-trimBelow</a></em> of <a href="index6160.html?post/skelconv">skelconv</a>, <em><a href="index4656.html?post/mse#robustness">-robustness</a></em> of <em><a href="index4656.html?post/mse">mse</a></em> and the <a href="index38d8.html?post/regular-grid-%3A-filaments#robustness">tutorial section</a> for more details and possible applications.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>An <strong>integral line</strong></ins><br /> is a curve tangent to the gradient field in every point. There exist exactly one integral line going through every non critical point of the domain of definition, and gradient lines must start and end at critical points (i.e. where the gradient is null).</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>descending k-manifold</strong></ins><br /> is a k dimensional region of space defined as the set of points from which following minus the gradient leads to the same critical point of critical index k, with N the dimension of the space (e.g. a descending N-manifold originates from a maximum). More details <a href="index1f6e.html?post/general-concepts">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>An <strong>ascending k-manifold</strong></ins><br /> is a k dimensional region of space defined as the set of points from which following the gradient leads to the same critical point of critical index N-k, where N is the dimension of the space (e.g. an ascending N-manifold originates from a minimum). More details <a href="index1f6e.html?post/general-concepts">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>Morse p-cell</strong></ins><br /> is a p-dimensional region of space defined by the intersection of an ascending and a descending manifold. All Integral lines in a morse p-cell originate and lead to the same critical points. More details <a href="index1f6e.html?post/general-concepts">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>Morse-Smale complex</strong></ins><br /> of a Morse function is the tessellation of space induced by its gradient : it divides space into regions where the integral lines originate from and lead to the same critical points. Its elements are the Morse p-cells. More details <a href="index1f6e.html?post/general-concepts">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>An <strong>arc</strong></ins><br /> is a Morse 1-cell : a 1D curve traced by the integral line that joins two critical points together. There is always exactly two arcs originating from a saddle point and leading to an extremum (i.e. a minimum or a maximum). In 3D and more however, the number of arcs linking two saddle point together is arbitrary. More details <a href="index1f6e.html?post/general-concepts">here</a>.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>skeleton</strong></ins><br /> is a set of arcs. We call <em>upper-</em>, <em>lower-</em>, and <em>inter-</em> skeleton the set of arcs that lead or originate from exactly one maximum, exactly one minimum, or none of the two respectively.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>filament</strong></ins><br /> is a 1-dimensional structure : an ascending or descending 1-manifold. A filament consists of the set of two arcs originating from a given saddle point and joining two extrema together (i.e. the yellow+green arcs on lower right frame of <a href="index1f6e.html?post/general-concepts">figure 1</a>). Unless explicitly stated, filaments join maxima together and we sometime call void filaments or anti-filaments the filaments that link minima together.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>wall</strong></ins><br /> is a 2-dimensional structure : an ascending or descending 2-manifold. Walls exist only in 3D and more and delimit the voids or peak patches.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>void</strong></ins><br /> is a N dimensional structure (<em>N</em> being the dimension of space): an ascending N-manifold that originates from a given minimum of the field. A void is the set of points from which following the gradient leads to a given minimum.</li>
</ul>
<p><br /></p>
<ul>
<li>- <ins>A <strong>peak patch</strong></ins><br /> is a N dimensional structure (<em>N</em> being the dimension of space): a descending N-manifold that originates from a given maximum of the field. Peak patches are the dual of voids: the set of points from which following the opposite of the gradient leads to the same maxima.</li>
</ul></div>
   

  

 <h2 class="category-title">
 <a href="index4f3e.html?category/Manual">Manual</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index4656.html?post/mse">mse</a>
   </h2>
      <div class="post-content"><p><strong>mse</strong> is the main program in DisPerSE, it is used to compute Morse-smale complexes and extract filamentary structures (i.e. arcs), voids and walls (ascending/descending manifolds), critical points and persistence pairs. By default, when no option is specified, the Morse-smale complex is computed and stored as a <em>filename.MSC</em> backup file in a format internal to mse, and no other file is produced. This file may later be loaded by mse (option <em><a href="#loadMSC">-loadMSC</a></em>) to skip the computation of the Morse-smale complex (this is useful when you want to produce different outputs from the same source).
<br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>mse</strong> &lt;<a href="#networkfilename">network filename</a>&gt; [-<a href="#field">field</a> &lt;fname&gt;]
     [-<a href="#outname">outName</a> &lt;fname&gt;] [-<a href="#notags">noTags</a>] [-<a href="#outdir">outDir</a> &lt;dir&gt;] 
     [-<a href="#periodicity">periodicity</a> &lt;val&gt;]
     [-<a href="#mask">mask</a> &lt;fname&gt;[~]]
     [-<a href="#nthreads">nthreads</a> &lt;N=$OMP_NUM_THREADS&gt;]
 
     [-<a href="#nsig">nsig</a> &lt;n1, n2, ...&gt;] [-<a href="#cut">cut</a> &lt;l1, l2, ...&gt;]
     [-<a href="#interactive">interactive</a> [&lt;full/path/to/pdview&gt;]]
     [-<a href="#forceloops">forceLoops</a>]
     [-<a href="#robustness">robustness</a>] [-<a href="#robustness">no_robustness</a>]
 
     [-<a href="#manifolds">manifolds</a>] [-<a href="#interarcsgeom">interArcsGeom</a>] [-<a href="#no_arcsgeom">no_arcsGeom</a>]
 
     [-<a href="#ppairs">ppairs</a>] [-<a href="#ppairs_ASCII">ppairs_ASCII</a>] 
     [-<a href="#upskl">upSkl</a>] [-<a href="#downskl">downSkl</a>] [-<a href="#interskl">interSkl</a>]
     [-<a href="#dumparcs">dumpArcs</a> &lt;CUID&gt;]
     [-<a href="#dumpmanifolds">dumpManifolds</a> [&lt;JEP0123456789ad&gt;]] 
 
     [-<a href="#compactify">compactify</a> &lt;type=natural&gt;]
     [-<a href="#vertexasminima">vertexAsMinima</a>] [-<a href="#descendingfiltration">descendingFiltration</a>] 
     [-<a href="#no_savemsc">no_saveMSC</a>] [-<a href="#loadMSC">loadMSC</a> &lt;fname&gt;]
 
     [-<a href="#no_gfilter">no_gFilter</a>]
     [-<a href="#diagram">diagram</a>] [-<a href="#smooth">smooth</a> &lt;Ntimes=0&gt;] 
     [-<a href="#debug">debug</a>]</pre>

<p><br /><a name="networkfilename"></a></p>
<ul>
<li><strong>&lt;network filename&gt;</strong>:<br />
<ul>
<li>The cell complex defining the topology of the space and optionally the function discretely sampled over it. The file may be a Healpix <em>FITS</em> file, a <a href="indexa0c1.html?post/field-formats">regular grid</a> or an <a href="index9cca.html?post/networks">unstructured network</a> readable by <em><a href="index25e8.html?post/netconv">netconv</a></em> or <em><a href="indexf1b8.html?post/fieldconv">fieldconv</a></em> (run <em>netconv</em> or <em>fieldconv</em> without argument for a list of supported file formats). The value of the function from which the Morse-smale complex will be computed should be given for each vertex (or pixel in case of a regular grid). In the case of an unstructured network, the function should be given in a field labeled <em>field_value</em>, or the function may also be set using option <em>-<a href="#field">field</a></em>.</li>
</ul></li>
</ul>
<p><br /><a name="field"></a></p>
<ul>
<li><strong>-field &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the scalar function whose morse complex will be computed. The function value should be given for each vertex (or pixel for regular grids), so the file must be a 1D array of values of size the number of vertices (or pixels) in the network, in a readable <a href="indexa0c1.html?post/field-formats">grid format</a>.</li>
</ul></li>
</ul>
<p><br /><a name="outname"></a></p>
<ul>
<li><strong>-outName &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the base name of the output file (extensions are added to this base name depending on the output type).<br /><ins>Default value</ins>: the name of the input network file.</li>
</ul></li>
</ul>
<p><br /><a name="outdir"></a></p>
<ul>
<li><strong>-outDir &lt;dir&gt;</strong>:<br />
<ul>
<li>Specifies the output directory. <br /><ins>Default value</ins>: the current working directory.</li>
</ul></li>
</ul>
<p><br /><a name="notags"></a></p>
<ul>
<li><strong>-noTags</strong>:<br />
<ul>
<li>Prevents mse from adding trailing extensions to the output filename such as the persistence cut levels ... Note that the last extension correponding to the file format is still added.</li>
</ul></li>
</ul>
<p><br /><a name="periodicity"></a></p>
<ul>
<li><strong>-periodicity &lt;val&gt;</strong>:<br />
<ul>
<li>Specifies the periodicity of the domain. This is only applicable to grid types networks, which are considered by default to have periodic boundaries. The parameter <em>&lt;val&gt;</em> is a serie of <em>1</em>s and <em>0</em>s enabling/disabling periodic boundary conditions along the corresponding direction.<br /><ins>Exemple</ins>: <em>-periodicity 0</em> sets non periodic boundaries conditions (PBC) while <em>-periodicity 101</em> sets PBC along dims <em>0</em> and <em>2</em> (<em>x</em> and <em>z</em>) but not along <em>y</em> axis.<br /><ins>Default value</ins>: by default, boundary conditions are fully periodic.</li>
</ul></li>
</ul>
<p><br /><a name="mask"></a></p>
<ul>
<li><strong>-mask &lt;fname&gt; [~]</strong>:<br />
<ul>
<li>Specifies a mask. The file must be a 1D array of values of size the number of vertices (or pixels) in the network, in a readable <a href="indexa0c1.html?post/field-formats">grid format</a>. By default, a value of <em>0</em> corresponds to a visible vertex/pixel while any other value masks the vertex/pixel. Adding a trailing <em>~</em> to the filename (without space) reverses this behavior, a value of 0 masking the corresponding pixels/vertices.</li>
</ul></li>
</ul>
<p><br /><a name="nthreads"></a></p>
<ul>
<li><strong>-nthreads &lt;N=$OMP_NUM_THREADS&gt;</strong>:<br />
<ul>
<li>Specifies the number of threads.<br /><ins>Default value</ins>: the number of threads is set by the environment variable <em>$OMP_NUM_THREADS</em>  which is usually set to the total number of cores available by <em>openMP</em>.</li>
</ul></li>
</ul>
<p><br /><a name="nsig"></a></p>
<ul>
<li><strong>-nsig &lt;n1, n2, ...&gt;</strong>:<br />
<ul>
<li>Specifies the persistence ratio threshold in terms of "number of sigmas". Any persistence pair with a persistence ratio (i.e. the ratio of the values of the points in the pair) that has a probability less than "n-sigmas" to appear in a random field will be cancelled. This may only be used for discretely sampled density fields (such as N-body simulations or discrete objects catalogs) whose density was estimated through the DTFE of a delaunay tesselation. This option is typically used when the input network was produced using <a href="index490e.html?post/Usage">delaunay_2D</a> or <a href="index490e.html?post/Usage">delaunay_3D</a>, in any other case, use <em>-cut</em> instead. See also option <a href="#interactive">-interactive</a></li>
</ul></li>
</ul>
<p><br /><a name="cut"></a></p>
<ul>
<li><strong>-cut &lt;l1, l2, ...&gt;</strong>:<br />
<ul>
<li>Specifies the persistence threshold. Any persistence pair with persistence (i.e. the difference of value between the two points in the pair) lower than the given threshold will be cancelled. Use <em>-nsig</em> instead of this when the input network was produced with <em><a href="index490e.html?post/Usage">delaunay_2D</a></em> or <em><a href="index490e.html?post/Usage">delaunay_3D</a></em>. The cut value should be typically set to the estimated amplitude of the noise. See also option <a href="#interactive">-interactive</a>.</li>
</ul></li>
</ul>
<p><br /><a name="interactive"></a></p>
<ul>
<li><strong>-interactive [&lt;full/path/to/pdview&gt;]</strong>:<br />
<ul>
<li>This option allows the user to interactively select the persistence threshold on a persistence diagram (using <a href="index8707.html?post/pdview">pdview</a>). if option <em>-cut</em> or <em>-nsig</em> is also used, the specified values are become default thresholds in pdview. The path to <em><a href="index8707.html?post/pdview">pdview</a></em> may be optionally indicated in case it cannot be found automatically.<br /><ins>Note</ins>: this option may only be used if pdview was compiled (requires <em>mathGL</em> and <em>Qt4</em> libraries).</li>
</ul></li>
</ul>
<p><br /><a name="forceloops"></a></p>
<ul>
<li><strong>-forceLoops</strong>:<br />
<ul>
<li>Forces the simplification of non-cancellable persistence pairs (saddle-saddle pairs in 3D or more that are linked by at least 2 different arcs). When two critical points of critical index difference 1 are linked by 2 or more arcs, they may not be cancelled as this would result in a discrete gradient loop. This is not a problem in 2D as such pairs cannot form persistence pairs but in 3D, saddle-saddle persistence pairs may be linked by 2 or more arcs even though their persistence is low. By default those pairs are skipped in order to preserve the properties of the Morse-smale complex but as a result few non persistent features may remain (such as spurious filaments). Fortunately, there are usually none or only very few of those pairs, and their number is shown in the output of mse, in the <em>Simplifying complex</em> section. If you are only interested in identifying structures (as opposed to doing topology),  you should probably use '-forceLoops' to remove those spurious structures (such as small non significant filaments).</li>
</ul></li>
</ul>
<p><br /><a name="robustness"></a></p>
<ul>
<li><strong>-robustness / -no_robustness</strong>:<br />
<ul>
<li>Enables or prevents the computation of <em><a href="index959e.html?post/definitions#robustness">robustness</a></em> and <em><a href="index959e.html?post/definitions#robustness">robustness ratio</a></em>. By default, <em>robustness</em> is not computed as it can be costly for very large data sets. When enabled, a robustness value is tagged for each segments and node of the output <a href="index661f.html?post/skeleton-formats">skeleton</a> files. See also options <em><a href="index6160.html?post/skelconv#trim">-trimBelow</a></em> of <a href="index6160.html?post/skelconv">skelconv</a> and the <a href="index38d8.html?post/regular-grid-%3A-filaments#robustness">tutorial section</a> for applications.</li>
</ul></li>
</ul>
<p><br /><a name="manifolds"></a></p>
<ul>
<li><strong>-manifolds</strong>:<br />
<ul>
<li>Forces the computation and storage of all <a href="index959e.html?post/definitions">ascending and descending manifolds</a> (i.e. walls, voids, ...). By default, mse only stores manifolds geometry if required (for instance, when the option <em><a href="#dumpmanifolds">-dumpManifolds</a></em> is used), and the resulting backup MSC file will therefore not contain this information and may not be used later to compute manifolds.<br /><ins>Example</ins>: running the command 'mse filename' will produce a the backup file 'filename.MSC' that stores the Morse-smale complex information. A later call to <em>mse -loadMSC filename.MSC -upSkl</em> would skip the computation of the MS-complex and succeed in producing the skeleton of the filamentary structures (arcs) as arcs geometry is computed by default. Unfortunately, <em>mse -loadMSC filename.MSC -dumpManifolds J0a</em> would fail as the information needed to compute the ascending 3-manifolds (i.e. manifolds originating from a minimum, which trace the voids) is not avaialble by default. Running <em>mse filename -manifolds</em> in the beginning would solve this problem.</li>
</ul></li>
</ul>
<p><br /><a name="interarcsgeom"></a></p>
<ul>
<li><strong>-interArcsGeom</strong>:<br />
<ul>
<li>This is similar to option <em><a href="#manifolds">-manifolds</a></em>, but for the arcs linking different types of saddle-points together (in 3D or more). By default, unless option <em><a href="#interskl">-interSkl</a></em> is specified, only the geometry of arcs linking extrema to saddle points is computed, so the backup <em>.MSC</em> file may not be used later to retrieve other types of arcs geometry. Specifying <em>-interArcsGeom</em> forces the computation and storage of all types of arcs in the <em>.MSC</em> backup file.</li>
</ul></li>
</ul>
<p><br /><a name="no_arcsgeom"></a></p>
<ul>
<li><strong>-no_arcsGeom</strong>:<br />
<ul>
<li>By default, the geometry of arcs linking extrema and saddle point is always computed even when not directly needed, so that it is stored in the backup <em>.MSC</em> file for later use. Specifying <em>-no_arcsGeom</em> may be used to lower memory usage when only the critical points and/or their persistence pairings are needed.<br /><ins>Exemple</ins>: <em>mse filename -ppairs -no_arcsGeom</em>  will compute the critical points and persistence pairs using less memory than <em>mse filename -ppairs</em>, but the resulting <em>.MSC</em> file may not be later used to retrieve arcs geometry.</li>
</ul></li>
</ul>
<p><br /><a name="ppairs"></a></p>
<ul>
<li><strong>-ppairs</strong>:<br />
<ul>
<li>Dumps the persistence pairs as a <em>NDnet</em> <a href="index9cca.html?post/networks">network type file</a>. The resulting file is a 1D network, where the critical points are the vertices and 1-cells (segments) represent pairs. Additional information such as the type, persistence, cell in the initial complex, ... of each critical points and pairs is also stored as additional information. Try running <em><a href="index25e8.html?post/netconv">netconv</a> filename.ppairs.NDnet -info</em> for a list of available additional data (see also <em>additional data</em> in the <a href="index9cca.html?post/networks">network file format</a> section).</li>
</ul></li>
</ul>
<p><br /><a name="ppairs_ascii"></a></p>
<ul>
<li><strong>-ppairs_ASCII</strong>:<br />
<ul>
<li>Same as <em>-<a href="#ppairs">ppairs</a></em> but pairs are dumped in a easily readable ASCII format. This option is deprecated and should not be used, use <em>-ppairs</em> option instead and then run <em><a href="index25e8.html?post/netconv">netconv</a> filename.ppairs.NDnet -to NDnet_ascii</em>.</li>
</ul></li>
</ul>
<p><br /><a name="upskl"></a></p>
<ul>
<li><strong>-upSkl</strong>:<br />
<ul>
<li>Dumps the "up" skeleton (i.e. arcs linking maxima to saddle-points, which trace the filamentary structures) as a <em>NDskl</em> type <a href="index661f.html?post/skeleton-formats">skeleton file</a>. This command is an alias of <em>-<a href="#dumparcs">dumpArcs</a> U</em>.</li>
</ul></li>
</ul>
<p><br /><a name="downskl"></a></p>
<ul>
<li><strong>-downSkl</strong>:<br />
<ul>
<li>Dumps the "down" skeleton (i.e. arcs linking minima to saddle-points, which trace the anti-filaments, or void filaments) as a <em>NDskl</em> type <a href="index661f.html?post/skeleton-formats">skeleton file</a>. This command is an alias of <em>-<a href="#dumparcs">dumpArcs</a> D</em>.</li>
</ul></li>
</ul>
<p><br /><a name="interskl"></a></p>
<ul>
<li><strong>-interSkl</strong>:<br />
<ul>
<li>Dumps the "inter" skeleton (i.e. arcs linking different types of saddle-points together) as a <em>NDskl</em> type <a href="index661f.html?post/skeleton-formats">skeleton file</a>. This will only work in 3D or more, and be careful that those type of arcs may have a very complex structure. This command is an alias of '-<a href="#dumparcs">dumpArcs</a> I''.</li>
</ul></li>
</ul>
<p><br /><a name="dumparcs"></a></p>
<ul>
<li><strong>-dumpArcs &lt;CUID&gt;</strong>:<br />
<ul>
<li>Dumps the specified type of <a href="index959e.html?post/definitions">arcs</a> (i.e filaments) as a <em>NDskl</em> type <a href="index661f.html?post/skeleton-formats">skeleton file</a>. Any combination of the letter <em>C</em>, <em>U</em>, <em>I</em> and <em>D</em> may be used as parameter to indicate which type of arc should be saved:<br />
<ul>
<li>-<em>U</em>(p): arcs leading to maxima (see also <em><a href="#upskl">-upSkl</a></em>).</li>
<li>-<em>D</em>(own): arcs leading to minima (see also <em><a href="#downskl">-downSkl</a></em>).</li>
<li>-<em>I</em>(nter): other arcs linking saddle-points together (see also <em><a href="#interskl">-interSkl</a></em>).</li>
<li>-<em>C</em>(onnect): keeps at least the connectivity information for all types of arcs.<br /></li>
</ul></li>
<li><ins>Exemple</ins>: <em>CUD</em> dumps geometry of arcs for which one extremity is and extremum (a maximum or a minimum), and the connectivity of saddle points is also stored (i.e. one can retrieve how they are linked in the Morse-Smale complex but not the actual geometry of the corresponding arcs).</li>
</ul></li>
</ul>
<p><br /><a name="dumpmanifolds"></a></p>
<ul>
<li><strong>-dumpManifolds [&lt;JEP0123456789ad&gt;]</strong>:<br />
<ul>
<li>Dumps <a href="index959e.html?post/definitions">ascending and/or descending manifolds</a> (i.e. walls, voids, ...) as a <em>NDnet</em> type <a href="index9cca.html?post/networks">network file</a>. The first part of the argument must be a combination of letters <em>J</em>, <em>E</em> and <em>P</em> and the second, which indicates the type of manifold to dump as a digit indicating the critical index of the critical point it originates from followed by the letter <em>a</em> and/or <em>d</em> to select ascending and/or descending manifolds respectively:
<ul>
<li>- <em>J</em>(oin): join all the the manifolds in one single file. By default, one file is created for each manifold.</li>
<li>- <em>E</em>(xtended): compute extended manifolds. For instance, when computing an ascending 2-manifold (i.e. a wallseparating two voids), the ascending 1-manifolds (i.e. filaments) on its boundary as well as the ascending 0-manifolds (i.e. critical points) on their boundaries are also dumped.</li>
<li>- <em>P</em>(reserve): do not merge infinitely close submanifolds. By default, the overlapping part of manifolds are merged (e.g. filaments may have bifurcation points but arcs only stop at critical points, so although two arcs continue above the bifurcation, only one path is stored). Using this option preserve the properties of the MS-complex but may result in very large files.</li>
<li>- <em>D</em>(ual): compute dual cells geometry when appropriate. Descending and ascending manifolds are the dual of one another, so they should be represented by cells of the complex and their dual respectively. When this option is used, appropriate cells are replaced by their dual (for instance, ascending 0-manifolds of a delaunay tesselation are represented by sets of voronoi 3-cells, the dual of the 0-cells (vertices) of the delaunay tesselation). The default behavior is that descending manifolds belong to the dual, so ascending manifolds are always fine but one may want to use option <em>D</em> to compute dual cells or option <em><a href="#vertexasminima">-vertexAsMinima</a></em> to change this behavior in order to obtain correct descending manifolds.</li>
<li>- <em>0123456789</em>: specifies the critical index of the critical points from which the manifold originates (ascending 0,1,2 and 3-manifolds in 3D trace the voids, walls, filaments and maxima/sources respectively).</li>
<li>- <em>a/d</em>: compute the ascending and/or descending manifold.</li>
</ul></li>
<li><ins>Exemple 1</ins>: in 3D, argument <em>JD0a2ad3d</em> would dump to a single file the ascending manifolds of critical index 0 and 2, and the descending ones for critical index 2 and 3. Cells are replaced by their dual where appropriate (i.e. in 3D, the descending 2-manifolds would be 2-cells dual of segments, and descending 3 manifolds would be 3-cells dual to vertices).</li>
<li><ins>Exemple 2</ins>: in 3D, argument <em>JE0a</em> would dump the union of the tetrahedrons within the voids, the walls separating the voids, as well as the filaments on their boundaries and the maxima at their extremity, as sets of triangles, segments and vertices of the input complex respectively, to a single file. As option <em>P</em> was not used, any overlapping region would be stored only once.</li>
</ul></li>
</ul>
<p><br /><a name="compactify"></a></p>
<ul>
<li><strong>-compactify &lt;type=natural&gt;</strong>:<br />
<ul>
<li>This option is used to specify how to treat boundaries of manifolds with boundary (this option does not affect manifolds without boundary). Available type are:
<ul>
<li>- 'natural' is the default value, and almost always the best choice.</li>
<li>- 'torus' creates reflective (i.e periodic) boundaries.</li>
<li>- 'sphere' links boundaries to a cell at infinity.</li>
</ul></li>
</ul></li>
</ul>
<p><br /><a name="vertexasminima"></a></p>
<ul>
<li><strong>-vertexAsMinima</strong>:<br />
<ul>
<li>As mse uses discrete Morse theory, each type of critical point corresponds to a particular cell type. By defaults, 0-cells (vertices) are maxima, 1-cells are saddle points, .... and d-cells are minima (d is the number of dimensions). Using <em>-vertexAsMinima</em>, the association is reversed and 0-cells are associated to minima ... while d-cells are associated to maxima. This option can be useful to identify manifolds or arcs as lists of a particular type of cell.<br /><ins>Example</ins>: <em>mse input_filename -<a href="#dumpmanifolds">dumpManifolds</a> J0a -vertexAsMinima</em> can be used to identify voids (ascending 0-manifolds) as sets of 0-cells (vertices). As a result, voids are identified as sets of pixels or  particles (if input_filename is a grid or the delaunay tesselation of an N-body simulation respectiveley), which is easy to relate to the pixels/particles of the input file. If the command <em>mse input_filename -dumpManifolds J0a</em> had been issued instead, each void would have been described by a set of n-cells (in nD).</li>
</ul></li>
</ul>
<p><br /><a name="descendingfiltration"></a></p>
<ul>
<li><strong>-descendingFiltration</strong>:<br />
<ul>
<li>By default, <em>mse</em> uses an ascending filtration to compute the discrete gradient. This option forces the program to use a descending filtration instead. Not that if mse works correctly (and it should hopefully be the case) the general properties of the Morse-smale complex are not affected, but simply critical points and  manifolds geometry will slightly differ.</li>
</ul></li>
</ul>
<p><br /><a name="no_savemsc"></a></p>
<ul>
<li><strong>-no_saveMSC</strong>:<br />
<ul>
<li>Use this if you do not want <em>mse</em> to write a backup <em>.MSC</em> file.</li>
</ul></li>
</ul>
<p><br /><a name="loadMSC"></a></p>
<ul>
<li><strong>-loadMSC &lt;fname&gt;</strong>:<br />
<ul>
<li>Loads a given backup <em>.MSC</em> file. This will basically skip the computation of the Morse-smale complex, therefore gaining a lot of time. By default, mse always write a backup <em>.MSC</em> after the MS-complex is computed. See options <em><a href="#manifolds">-manifolds</a></em> and <em><a href="#interarcsgeom">-interArcsGeom</a></em> for information on the limitations.</li>
</ul></li>
</ul>
<p><br /><a name="no_gfilter"></a></p>
<ul>
<li><strong>-no_gFilter</strong>:<br />
<ul>
<li>Prevents the filtration of null-persistence pairs in the discrete gradient. There is no point in using this option except for debugging ...</li>
</ul></li>
</ul>
<p><br /><a name="diagram"></a></p>
<ul>
<li><strong>-diagram</strong>:<br />
<ul>
<li>Draws a diagram of the connectivity of critical points to a <em>.ps</em> file. This should only be used when the number of critical points is very small (i.e. less than 100 or so).</li>
</ul></li>
</ul>
<p><br /><a name="smooth"></a></p>
<ul>
<li><strong>-smooth &lt;Ntimes=0&gt;</strong>:<br />
<ul>
<li>Deprecated, don't use it ... use <em><a href="index6160.html?post/skelconv">skelconv</a> -smooth &lt;Ntimes=0&gt;</em> or <em><a href="index25e8.html?post/netconv">netconv</a> -smooth &lt;Ntimes=0&gt;</em> on the output files instead.</li>
</ul></li>
</ul>
<p><br /><a name="debug"></a></p>
<ul>
<li><strong>-debug</strong>:<br />
<ul>
<li>Outputs some debug information and files.</li>
</ul></li>
</ul>
<p><br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index490e.html?post/Usage">delaunay_nD</a>
   </h2>
      <div class="post-content"><p><strong>Delaunay_2D</strong> and <strong>Delaunay_3D</strong> are used to compute the Delaunay tessellation of a discrete particle distribution (such as a N-Body simulation or a catalog of object coordinates) in 2D and 3D respectively and possibly in parallel. The output is an <a href="index9cca.html?post/networks">unstructured network</a> in <em>NDnet</em> format, with density computed for each vertex using DTFE (i.e. density at a given vertex is proportional to the total volume of the surrounding cells). In order to compute the correct topology and density close to the boundaries, the distribution is extrapolated over a band outside the domain of definition (see options <em>-<a href="#margin">margin</a></em>, <em>-<a href="#btype">btype</a></em> and <em>-<a href="#periodic">periodic</a></em>). The output network can be used as input file for <a href="index4656.html?post/mse">mse</a> to compute the Morse-Smale complex of the initial discrete sample (the index of the vertices in the output network correspond to the index of the sampling particles in the input file).
<br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>delaunay_nD</strong> &lt;<a href="#fname">fname</a>&gt; [-<a href="#outName">outName</a> &lt;fname&gt;] [-<a href="#outDir">outDir</a> &lt;dir&gt;]
             [-<a href="#subbox">subbox</a> &lt;x0&gt; &lt;y0&gt; [&lt;z0&gt;] &lt;dx&gt; &lt;dy&gt; [&lt;dz&gt;]]
             [-<a href="#periodic">periodic</a>] [-<a href="#minimal">minimal</a>]
             [-<a href="#blocks">blocks</a> &lt;NChunks&gt; &lt;NThreads&gt;]
             [-<a href="#margin">margin</a> &lt;M&gt;] [-<a href="#btype">btype</a> &lt;t=mirror&gt;]
             [-<a href="#mask">mask</a> &lt;fname.ND&gt;]
             [-<a href="#smooth">smooth</a> &lt;N=0&gt;]
             [-<a href="#angmask">angmask</a> &lt;fname.fits&gt; [&lt;maximum angular size (degrees) = 5.00&gt;]]
             [-<a href="#radialDensity">radialDensity</a> &lt;A&gt; &lt;Dr&gt; &lt;B&gt;]
             [-<a href="#subSample">subSample</a> &lt; 0&lt;s&lt;1 &gt;]</pre>

<p><br /><a name="fname"></a></p>
<ul>
<li><strong>&lt;fname&gt;</strong>:<br />
<ul>
<li>The name of a file containing the discrete particle coordinates in a <a href="indexa0c1.html?post/field-formats">field</a> format.</li>
</ul></li>
</ul>
<p><br /><a name="outName"></a></p>
<ul>
<li><strong>-outName &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the base name of the file in output (extensions are added to this base name depending on the output type).<br /><ins>Default value</ins>: the name of the input  file.</li>
</ul></li>
</ul>
<p><br /><a name="outDir"></a></p>
<ul>
<li><strong>-outDir &lt;dir&gt;</strong>:<br />
<ul>
<li>Specifies the output directory. <br /><ins>Default value</ins>: the current working directory.</li>
</ul></li>
</ul>
<p><br /><a name="subbox"></a></p>
<ul>
<li><strong>-subbox &lt;x0&gt; &lt;y0&gt; [&lt;z0&gt;] &lt;dx&gt; &lt;dy&gt; [&lt;dz&gt;]</strong>:<br />
<ul>
<li>Restricts the computation to a box of size [dx dy dz] and with origin [x0,y0,z0]. The box may be larger than the actual bounding box or cross its boundaries. The distribution outside the box will depend on the boundary type, as set with option <em>-<a href="#btype">btype</a></em>. Note that the distribution within the margin of the subbox (see option <em>-<a href="#margin">margin</a></em>) is still used to compute the topology close to the boundaries, so this option may be used to cut a large distribution into several small sub-boxes with matching boundary distribution.</li>
</ul></li>
</ul>
<p><br /><a name="periodic"></a></p>
<ul>
<li><strong>-periodic</strong>:<br />
<ul>
<li>Use this option to force periodic boundary conditions for the output network. When this option is used, <em>delaunay_nD</em> will try to reconnect the simplices crossing the bounding box so that the space is compactified to a torus. The operation may fail if the margin size is too small, as cells crossing opposite boundaries may not match, so always check the output of the program as an estimation of the correct margin size will be indicated in that case (see also option <em>-<a href="#margin">margin</a></em>). Note that this option wil set default boundary type to <em>-<a href="#btype">btype</a> periodic</em>.</li>
</ul></li>
</ul>
<p><br /><a name="minimal"></a></p>
<ul>
<li><strong>-minimal</strong>:<br />
<ul>
<li>when using this option, only the minimal necessary information to define the tesselation is stored in the output file (i.e. In dimensions D, the vertex coordinates and simplices of dimension D, and the additional data associated to them). Note that it is preferable NOT to use this option when the ouput file is to be fed to <a href="index4656.html?post/mse">mse</a>, as it will force the program to recompute the topology of intermediate simplices using a slower algorithm every time it is run.</li>
</ul></li>
</ul>
<p><br /><a name="blocks"></a></p>
<ul>
<li><strong>-blocks &lt;NChunks&gt; &lt;NThreads&gt;</strong>:<br />
<ul>
<li>instead of computing the delaunay tesselation of the full distribution, divide it into <em>NChunks</em> overlapping sub blocks and process them <em>NThreads</em> at a time. The subblocks are then automatically reassembled into the full delaunay tesselation. This option can either be used to increase speed by parallelizing the process (for high values of <em>NThreads</em>) or decrease the memory consumption (when <em>NChunks</em>&gt;&gt;<em>NThreads</em>). Note that it is incompatible with options <em>-<a href="#mask">mask</a></em>, <em>-<a href="#btype">btype</a> smooth</em>, <em>-<a href="#angmask">angmask</a></em> and <em>-<a href="#radialDensity">radialDensity</a></em>.</li>
</ul></li>
</ul>
<p><br /><a name="margin"></a></p>
<ul>
<li><strong>-margin &lt;M&gt;</strong>:<br />
<ul>
<li>Suggests a startup trial size for the additional margin used to compute the topology and density close to the boundary. The margin size is expressed as a fraction of the bounding box (or subbox if option <em>-<a href="#subbox">subbox</a></em> is used). Note the the program can probably make a better guess than you so it is not recommanded to set it by hand ...</li>
</ul></li>
</ul>
<p><br /><a name="btype"></a></p>
<ul>
<li><strong>-btype &lt;t=mirror&gt;</strong>:<br />
<ul>
<li>This option sets the type of the boundaries. This option is used to set how the distribution should be extrapolated  outside the bounding box (an estimation of the distribution outside the bounding box is needed to correctly estimate the topology and density of the distribution close to its boundaries). Possible boundary types are:
<ul>
<li>- <em>mirror</em> : the distribution outside the bounding box is a mirrored copy of that inside.</li>
<li>- <em>periodic</em> : use periodic boundary condition (i.e. space is paved with copies of the distribution in the bounding box). Note that this option does *NOT* enforce periodic boundary conditions as it does not tell <em>delaunay_nD</em> to reconnect the Delaunay cells that cross the bounding box (this is achieved with <em>-<a href="#periodic">periodic</a></em>).</li>
<li>- <em>smooth</em> : a surface of guard particles is added outside the bounding box and new particles are added by interpolating the estimated density computed on the boundary of the distribution. This boundary type is useful when the actual boundaries of the sample are complex (i.e. not a cube), such as for a 3D galaxy catalog limited to a portion of the sky.</li>
<li>- <em>void</em> : the distribution is supposed to be void outside the bounding box.</li>
</ul></li>
</ul></li>
</ul>
<p><br /><a name="mask"></a></p>
<ul>
<li><strong>-mask &lt;fname.ND&gt;</strong>:<br />
<ul>
<li>Specifies a mask. The file must be a 1D array of values of size the number of vertices (or pixels) in the network, in a readable <a href="indexa0c1.html?post/field-formats">grid format</a>. A value of <em>0</em> corresponds to a non-masked particle while any other value masks the particle. Note that masked particles are still used to compute the Delaunay tessellation and estimate the density but they will change the topology of the actual distribution.</li>
</ul></li>
</ul>
<p><br /><a name="smooth"></a></p>
<ul>
<li><strong>-smooth &lt;N=0&gt;</strong>:<br />
<ul>
<li>Smooth the estimated DTFE density by averaging N times its value at each vertex with that at the neighboring vertices (i.e two vertices are considered neighbors if they both belong to the boundary of at list one given cell).</li>
</ul></li>
</ul>
<p><br /><a name="angmask"></a></p>
<ul>
<li><strong>-angmask &lt;fname.fits&gt; [&lt;maximum angular size (degrees) = 5.00&gt;]</strong>:<br />
<ul>
<li>Not documented ... you should not use it anyway :)</li>
</ul></li>
</ul>
<p><br /><a name="radialDensity"></a></p>
<ul>
<li><strong>-radialDensity &lt;A&gt; &lt;Dr&gt; &lt;B&gt;</strong>:<br />
<ul>
<li>Not documented ...</li>
</ul></li>
</ul>
<p><br /><a name="subSample"></a></p>
<ul>
<li><strong>-subSample &lt; 0&lt;s&lt;1 &gt;</strong>:<br />
<ul>
<li>Computes the Delaunay tessellation over a subsets of the actual distribution containing only a randomly selected fraction <em>0&lt;s&lt;1</em> of the particles.</li>
</ul></li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index8707.html?post/pdview">pdview</a>
   </h2>
      <div class="post-content"><p><strong>pdview</strong> is used to interactively select the persistence threshold with the help of a persistence diagram. A persistence diagram is a 2D plot in which all the persistence pairs are represented by points with coordinates the value at the critical points in the pair (see <a href="indexd3dd.html?post/Persistence-and-simplification">this section</a> for more info). In <em>pdview</em>, we rather represent the value of the lower critical index on the x axis and the absolute difference in value between the two critical points on the y axis (i.e. the persistence of the pair). The diagram is computed from a <a href="index9cca.html?post/networks">network</a> file encoding the persistence pairs as output by <em><a href="index4656.html?post/mse">mse</a> filename -ppairs</em>. Press the button labeled <em>?</em> in <strong>pdview</strong> for more information on how to use it.
<br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>pdview</strong> &lt;<a href="#filename">filename</a>&gt; [-<a href="#dtfe">dtfe</a>] [-<a href="#nsig">nsig</a> &lt;val&gt;] [-<a href="#cut">cut</a> &lt;val&gt;]</pre>

<p><br /><a name="filename"></a></p>
<ul>
<li><strong>&lt;filename&gt;</strong>:<br />
<ul>
<li>The name of an <a href="index9cca.html?post/networks">unstructured network</a> file containing the persistence pairs, as output by ''<a href="index4656.html?post/mse">mse</a>.</li>
</ul></li>
</ul>
<p><br /><a name="dtfe"></a></p>
<ul>
<li><strong>-dtfe</strong>:<br />
<ul>
<li>Use this option if the persistence pairs were computed from a network estimated through DTFE (i.e. the output of <a href="index490e.html?post/Usage">delaunay_nD</a>).</li>
</ul></li>
</ul>
<p><br /><a name="nsig"></a></p>
<ul>
<li><strong>-nsig &lt;val&gt;</strong>:<br />
<ul>
<li>Sets a default persistence threshold ratio expressed in <em>N-sigmas</em> (see option <em>-nsig</em> in <a href="index4656.html?post/mse">mse</a>).</li>
</ul></li>
</ul>
<p><br /><a name="cut"></a></p>
<ul>
<li><strong>-cut &lt;val&gt;</strong>:<br />
<ul>
<li>Sets a default persistence threshold (see option <em>-cut</em> in <a href="index4656.html?post/mse">mse</a>).</li>
</ul></li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index25e8.html?post/netconv">netconv</a>
   </h2>
      <div class="post-content"><p><strong>netconv</strong>  is used to post-treat, convert and display information about  <a href="index9cca.html?post/networks">unstructured network format</a> files. Run <em>netconv</em> without argument to see a list of available input and output formats.</p>


<p><br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>netconv</strong> &lt;<a href="#filename">filename</a>&gt; 
         [-<a href="#outName">outName</a> &lt;output filename&gt;] [-<a href="#outDir">outDir</a> &lt;dir&gt;]
         [-<a href="#addField">addField</a> &lt;filename&gt; &lt;field name&gt;] [-<a href="#smooth">smooth</a> &lt;Ntimes=0&gt;] 
         [-<a href="#smoothData">smoothData</a> &lt;vertex field name&gt; &lt;Ntimes&gt;] 
         [-<a href="#noTags">noTags</a>] [-<a href="#toRaDecZ">toRaDecZ</a>] [-<a href="#toRaDecDist">toRaDecDist</a>] 
         [-<a href="#info">info</a>] [-<a href="#to">to</a> &lt;format&gt;]</pre>

<p><br /><a name="filename"></a></p>
<ul>
<li><strong>&lt;filename&gt;</strong>:<br />
<ul>
<li>The name of a file containing an unstructured network (for instance, persistence pairs or manifolds as output by <a href="index4656.html?post/mse">mse</a>) in a readable <a href="index9cca.html?post/networks">network file format</a>.</li>
</ul></li>
</ul>
<p><br /><a name="outName"></a></p>
<ul>
<li><strong>-outName &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the base name of the output file (extensions are added to this base name depending on the output type).<br /><ins>Default value</ins>: the name of the input file.</li>
</ul></li>
</ul>
<p><br /><a name="outDir"></a></p>
<ul>
<li><strong>-outDir &lt;dir&gt;</strong>:<br />
<ul>
<li>Specifies the output directory. <br /><ins>Default value</ins>: the current working directory.</li>
</ul></li>
</ul>
<p><br /><a name="addField"></a></p>
<ul>
<li><strong>-addField &lt;filename&gt; &lt;field_name&gt;</strong>:<br />
<ul>
<li>Tags each vertex of the network with the interpolated value of a field. The parameter <em>filename</em> is the name of a readable <a href="indexa0c1.html?post/field-formats">regular grid field format</a> file containing the grid to be interpolated, and <em>field_name</em> is the name of the additional field in the output file.</li>
</ul></li>
</ul>
<p><br /><a name="smooth"></a></p>
<ul>
<li><strong>-smooth &lt;Ntimes=0&gt;</strong>:<br />
<ul>
<li>Smooth the network N times. Smoothing is achieved by averaging the position of each vertex with that of its direct neighbors (i.e. those that belong to the boundary of at least one common simplex).  In practice, smoothing <em>N</em> times makes the network smooth over the local size of '~N' network cells. Smoothing is first achieved only on vertices sharing at least a common 3-simplex, then a 2-simplex, ... So for instance when smoothing manifolds such as output by <em><a href="index4656.html?post/mse">mse</a> -dumpManifolds JE0a</em>, walls will be smoothed independently of filaments and critical points (try it yourself to understand ...).</li>
</ul></li>
</ul>
<p><br /><a name="smoothData"></a></p>
<ul>
<li><strong>-smoothData &lt;vertex_field_name&gt; &lt;Ntimes&gt;</strong>:<br />
<ul>
<li>smooth the <em>vertex_field_name</em> data field associated with vertices by averaging its value with that of its direct neighbors in the network <em>Ntimes</em> times.</li>
</ul></li>
</ul>
<p><br /><a name="noTags"></a></p>
<ul>
<li><strong>-noTags</strong>:<br />
<ul>
<li>Prevents <em>netconv</em> from adding trailing extensions to the output filename. Note that the last extension correponding to the file format is still added.</li>
</ul></li>
</ul>
<p><br /><a name="toRaDecZ"></a></p>
<ul>
<li><strong>-toRaDecZ</strong>:<br />
<ul>
<li>Converts the coordinates to Ra (Right ascension), Dec (Declination) and Z (redshift). This is useful when the input file was computed from a particle distribution whose coordinates where given in the same system (such as a galaxy catalog for instance, see catalog format in <a href="indexa0c1.html?post/field-formats">field format</a>).</li>
</ul></li>
</ul>
<p><br /><a name="toRaDecDist"></a></p>
<ul>
<li><strong>-toRaDecDist</strong>:<br />
<ul>
<li>Converts the coordinates to Ra (Right ascension), Dec (Declination) and Dist (Distance). This is useful when the input file was computed from a particle distribution whose coordinates where given in the same system (such as a galaxy catalog for instance, see catalog format in <a href="indexa0c1.html?post/field-formats">field format</a>).</li>
</ul></li>
</ul>
<p><br /><a name="info"></a></p>
<ul>
<li><strong>-info</strong>:<br />
<ul>
<li>Prints information on the input file, such as the number of each type of cell and the name and type of additional fields.</li>
</ul></li>
</ul>
<p><br /><a name="to"></a></p>
<ul>
<li><strong>-to &lt;format&gt;</strong>:<br />
<ul>
<li>Outputs a file in the selected writable <a href="index9cca.html?post/networks">unstructured network format</a>. A list of possible parameter values can be obtained by running <em>netconv</em> without any argument.</li>
</ul></li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index6160.html?post/skelconv">skelconv</a>
   </h2>
      <div class="post-content"><p><strong>skelconv</strong>  is used to post-treat, convert and display information about <a href="index661f.html?post/skeleton-formats">skeleton format</a> files. Run <em>skelconv</em> without argument to see a list of available input and output formats. Note that skeleton files can also be converted to <a href="index9cca.html?post/networks">NDnet format</a> unstructured networks readable by <a href="index25e8.html?post/netconv">netconv</a>.
<br /><ins><strong>nb</strong></ins>: in skelconv, the order of the argument on the command line is important and certain post-treatment do not commute.  In particular, be careful when using options <em>-<a href="#breakdown">breakdown</a></em>, <em>-<a href="#trim">trim</a></em>, <em>-<a href="#smooth">smooth</a></em> or <em>-<a href="#assemble">assemble</a></em> together as for instance <em>-smooth 3 -breakdown</em> or <em>-breakdown -smooth 3</em> will not produce the same output.
<br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>skelconv</strong> &lt;<a href="#filename">filename</a>&gt; 
          [-<a href="#outName">outName</a> &lt;output filename&gt;] [-<a href="#outDir">outDir</a> &lt;dir&gt;] [-<a href="#noTags">noTags</a>]
          [-<a href="#smooth">smooth</a> &lt;Ntimes=0&gt;] [-<a href="#breakdown">breakdown</a>]
          [-<a href="#assemble">assemble</a> [[&lt;field_name&gt;] &lt;threshold&gt;] &lt;angle&gt;]
          [-<a href="#trim">trimAbove</a> [&lt;field_name&gt;] &lt;threshold&gt;] 
          [-<a href="#trim">trimBelow</a> [&lt;field_name&gt;] &lt;threshold&gt;] 
          [-<a href="#rmBoundary">rmBoundary</a>] [-<a href="#rmOutside">rmOutside</a>]
          [-<a href="#toRaDecZ">toRaDecZ</a>] [-<a href="#toRaDecDist">toRaDecDist</a>]
          [-<a href="#toFITS">toFITS</a> [&lt;Xres&gt;] [&lt;Yres&gt;] [&lt;Zres&gt;]]
          [-<a href="#info">info</a>] [-<a href="#addField">addField</a> &lt;filename&gt; &lt;field_name&gt;] [-<a href="#to">to</a> &lt;format&gt;]</pre>

<p><br /><a name="filename"></a></p>
<ul>
<li><strong>&lt;filename&gt;</strong>:<br />
<ul>
<li>The name of a file containing a skeleton such as skeletons (filaments) output by <a href="index4656.html?post/mse">mse</a> in a readable <a href="index661f.html?post/skeleton-formats">skeleton format</a>.</li>
</ul></li>
</ul>
<p><br /><a name="outName"></a></p>
<ul>
<li><strong>-outName &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the base name of the output file (extensions are added to this base name depending on the output type).<br /><ins>Default value</ins>: the name of the input file.</li>
</ul></li>
</ul>
<p><br /><a name="outDir"></a></p>
<ul>
<li><strong>-outDir &lt;dir&gt;</strong>:<br />
<ul>
<li>Specifies the output directory. <br /><ins>Default value</ins>: the current working directory.</li>
</ul></li>
</ul>
<p><br /><a name="noTags"></a></p>
<ul>
<li><strong>-noTags</strong>:<br />
<ul>
<li>Prevents <em>skelconv</em> from adding trailing extensions to the output filename. Note that the last extension correponding to the file format is still added.</li>
</ul></li>
</ul>
<p><br /><a name="smooth"></a></p>
<ul>
<li><strong>-smooth &lt;Ntimes=0&gt;</strong>:<br />
<ul>
<li>Smooth the skeleton N times. When using this option, the nodes (i.e. critical points) are fixed and the filaments are smoothed by averaging the coordinates of each points along a filament with that of its two neighbors. Smoothing <em>N</em> times effectively make filaments smooth over <em>~N</em> sampling points.</li>
</ul></li>
</ul>
<p><br /><a name="breakdown"></a></p>
<ul>
<li><strong>-breakdown</strong>:<br />
<ul>
<li>By default, skeletons are composed of arcs linking critical points together, so an arc will always start and stop at a critical point. Different arcs with same destination may partially overlap though, between a so-called bifurcation and a critical point. If N arcs overlap in a given place, the N segments will describe their geometry in that place : this is topologically correct but may not be desirable when computing statistics along the filaments as it would artificially increase the weight of those regions. Using <em>-breakdown</em>, bifurcation points are replaced by fake critical points with critical index D+1 (where D is the number of dimensions), and infinitely close pieces of arcs are merged. This option should most probably be used before computing any statistical quantity along arcs ...</li>
</ul></li>
</ul>
<p><br /><a name="assemble"></a></p>
<ul>
<li><strong>-assemble [[&lt;field_name&gt;] &lt;threshold&gt;] &lt;angle&gt;</strong>:<br />
<ul>
<li>Assemble arcs into longer filaments, with the constraint that they do not form an angle larger than <em>&lt;angle&gt;</em> (expressed in degrees) and optionally do not go below threshold <em>&lt;threshold&gt;</em> in the field <em>&lt;field_name&gt;</em>. See option <em>-<a href="#trim">trim</a></em> for explanations on the first two arguments. When using this option, the algorithm will try to find the longest possible aligned arcs and will join them, removing critical points and creating only straight filaments. Option <em>-<a href="#breakdown">breakdown</a></em> should almost always be used before using this (e.g. <em>skelconv filename.NDskl -breakdown -assemble 0 45</em>).</li>
</ul></li>
</ul>
<p><br /><a name="trim"></a></p>
<ul>
<li><strong>-trimAbove/trimBelow [&lt;field_name&gt;] &lt;threshold&gt;</strong>:<br />
<ul>
<li>Trims the regions of the skeleton above or below threshold <em>&lt;threshold&gt;</em> and add nodes (fake critical points of index D+1) at the extremity of trimmed arcs. By default, the skeleton is trimmed according to <em>field_value</em> (i.e. the value of the function from which the skeleton was computed). One can specify a different function with <em>&lt;field_name&gt;</em> (a list of possible fields may be obtained running <em>skelconv filename.NDskl -info</em>). One particularly interesting trimming function is <em>robustness</em> which is an extension of the concept of persistence to each points of the arcs ( an improved version of the <em>separatrix persistence</em> described in <em>Weinkauf, T. and Gunther, D., 2009</em> ). Indeed, <em>robustness</em> can be considered a measure of how contrasted the filament is with respect to its <em>local</em> background, and it is therefore a good way to select only highly contrasted subsets of the filamentary structures. Note that robustness, like persistence, is defined as a difference or ratio between the value of the field in two points, so the robustness threshold has the same order of magnitude as the persistence threshold.</li>
</ul></li>
</ul>
<p><br /><a name="toRaDecZ"></a></p>
<ul>
<li><strong>-toRaDecZ</strong>:<br />
<ul>
<li>Converts the coordinates to Ra (Right ascension), Dec (Declination) and Z (redshift). This is useful when the input file was computed from a particle distribution whose coordinates where given in the same system (such as a galaxy catalog for instance, see catalog format in <a href="indexa0c1.html?post/field-formats">field format</a>).</li>
</ul></li>
</ul>
<p><br /><a name="toRaDecDist"></a></p>
<ul>
<li><strong>-toRaDecDist</strong>:<br />
<ul>
<li>Converts the coordinates to Ra (Right ascension), Dec (Declination) and Dist (Distance). This is useful when the input file was computed from a particle distribution whose coordinates where given in the same system (such as a galaxy catalog for instance, see catalog format in <a href="indexa0c1.html?post/field-formats">field format</a>).</li>
</ul></li>
</ul>
<p><br /><a name="rmBoundary"></a></p>
<ul>
<li><strong>-rmBoundary</strong>:<br />
<ul>
<li>Remove the arcs and nodes that lay on the boundary or outside the domain of definition (e.g. nodes/arcs at infinity generated by boundary conditions).</li>
</ul></li>
</ul>
<p><br /><a name="rmOutside"></a></p>
<ul>
<li><strong>-rmOutside</strong>:<br />
<ul>
<li>Remove the artificial arcs and nodes generated by the boundary conditions (e.g arcs/nodes at infinity) but keep boundaries (this is less restricitve than <em>-<a href="#rmBoundary">rmBoundary</a></em>).</li>
</ul></li>
</ul>
<p><br /><a name="toFITS"></a></p>
<ul>
<li><strong>-toFITS [&lt;Xres&gt;] [&lt;Yres&gt;] [&lt;Zres&gt;]</strong>:<br />
<ul>
<li>Samples the skeleton to a FITS image with specified resolution. If the resolution is omitted (parameters <em>Xres</em>, <em>Yres</em> and/or <em>Zres</em>), then the output file will have the same resolution as the network that was used to compute the skeleton.</li>
</ul></li>
</ul>
<p><br /><a name="info"></a></p>
<ul>
<li><strong>-info</strong>:<br />
<ul>
<li>Prints information on the input file, such as the number of arcs, critical points and the name and type of additional fields.</li>
</ul></li>
</ul>
<p><br /><a name="addField"></a></p>
<ul>
<li><strong>-addField &lt;filename&gt; &lt;field_name&gt;</strong>:<br />
<ul>
<li>Tags each segment (i.e. pieces of arcs) and node (i.e. critical point) of the skeleton with the interpolated value of a field. The parameter <em>filename</em> is the name of a readable <a href="indexa0c1.html?post/field-formats">regular grid field format</a> file containing the grid to be interpolated, and <em>field_name</em> is the name of the additional field in the output file.</li>
</ul></li>
</ul>
<p><br /><a name="to"></a></p>
<ul>
<li><strong>-to &lt;format&gt;</strong>:<br />
<ul>
<li>Outputs a file in the selected writable <a href="index661f.html?post/skeleton-formats">skeleton format</a>. A list of possible parameter values can be obtained by running <em>skelconv</em> without any argument. Note that skeleton files can be converted to <a href="index9cca.html?post/networks">NDnet format</a> unstructured networks readable by <a href="index25e8.html?post/netconv">netconv</a>.</li>
</ul></li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexf1b8.html?post/fieldconv">fieldconv</a>
   </h2>
      <div class="post-content"><p><strong>fieldconv</strong> is used to display information about <a href="indexa0c1.html?post/field-formats">field format</a> files encoding regular grid or point set coordinates, and convert them to other formats. Run <em>fieldconv</em> without argument to see a list of available input and output formats.</p>


<p><br />
<br /></p>


<p><ins>Usage:</ins></p>

<pre> <strong>fieldconv</strong> &lt;<a href="#filename">filename</a>&gt; 
           [-<a href="#outName">outName</a> &lt;output filename&gt;] [-<a href="#outDir">outDir</a> &lt;dir&gt;]
           [-<a href="#info">info</a>] [-<a href="#to">to</a> &lt;format&gt;]</pre>

<p><br /><a name="filename"></a></p>
<ul>
<li><strong>&lt;filename&gt;</strong>:<br />
<ul>
<li>The name of a file containing a regular grid or point set coordinates in a readable <a href="indexa0c1.html?post/field-formats">field format</a>.</li>
</ul></li>
</ul>
<p><br /><a name="outName"></a></p>
<ul>
<li><strong>-outName &lt;fname&gt;</strong>:<br />
<ul>
<li>Specifies the base name of the output file (extensions are added to this base name depending on the output type).<br /><ins>Default value</ins>: the name of the input file.</li>
</ul></li>
</ul>
<p><br /><a name="outDir"></a></p>
<ul>
<li><strong>-outDir &lt;dir&gt;</strong>:<br />
<ul>
<li>Specifies the output directory. <br /><ins>Default value</ins>: the current working directory.</li>
</ul></li>
</ul>
<p><br /><a name="info"></a></p>
<ul>
<li><strong>-info</strong>:<br />
<ul>
<li>Prints information on the input file.</li>
</ul></li>
</ul>
<p><br /><a name="to"></a></p>
<ul>
<li><strong>-to &lt;format&gt;</strong>:<br />
<ul>
<li>Outputs a file in the selected writable <a href="indexa0c1.html?post/field-formats">field format</a>. A list of possible parameter values can be obtained by running <em>fieldconv</em> without any argument.</li>
</ul></li>
</ul></div>
   

  

 <h2 class="category-title">
 <a href="index55a0.html?category/Quick-start">Tutorial</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index38d8.html?post/regular-grid-%3A-filaments">Persistence diagrams and filaments</a>
   </h2>
      <div class="post-content"><p>In this tutorial, we will identify the persistent filamentary structures in a diHydrogen column density map of the interstellar medium in the Eagle Nebula (M16) as observed by <a href="http://www.esa.int/herschel" title="herschel">Herschel</a> . The map is encoded in a 2D double precision FITS image, with pixels set to <em>NaN</em> in unobserved regions:
<br /><br />
<img src="../images/m16_blue.png" alt="M16_blue.png" style="display:block; margin:0 auto;" />
<br /><br />
By default, <a href="index4656.html?post/mse">mse</a> will automatically mask NaN valued pixels so the FITS file could theoretically be fed directly to it. However, because of the complexity of the geometry of the observed region, it is preferable to use a mask to limit the analysis to a well defined region of interest (in particular, it is preferable that this region is simply connected - i.e. does not contain holes -). Designing a mask is relatively simple, as it consists in an image with pixels set to 0 in non-masked region and any other value in the masked regions (this behavior can be changed by adding a trailing '~' to the mask filename, see option <em><a href="index4656.html?post/mse#mask">-mask</a></em>). The following mask was created with <em><a href="http://www.gimp.org/" title="gimp">Gimp</a></em> and saved as a <em>.PNG</em> file (any readable <a href="indexa0c1.html?post/field-formats">field file format</a> is acceptable):
<br /><br />
<img src="../images/m16_mask.png" alt="M16_mask.png" style="display:block; margin:0 auto;" />
<br /><br />
<br /><br />
With this mask, we can now use <em>mse</em> to identify the filamentary structures in the map (option <em><a href="index4656.html?post/mse#upskl">-upSkl</a></em>) with the help of an interactive persitence diagram (option <em><a href="index4656.html?post/mse#interactive">-interactive</a></em>) to select the correct persistent threshold as we do not want to impose any à-priori on its value. We therefore run the following command:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse m16_zo_no70um_density.fits -mask M16_mask.png -interactive -upSkl</div>


<p><br /><br />
After some computations, the following diagram should appear (use buttons <em>logX</em>/<em>logY</em> to switch logarithmic coordinate and buttons <em>1</em>, <em>2</em> and <em>3</em> to show/hide different types of persistence pairs):
<br /><br />
<img src="../images/m16_persistence_diagram_2.png" alt="M16_persistence_diagram_2.png" style="display:block; margin:0 auto;" />
<br /><br />
On this diagram, each dot represents a <a href="index959e.html?post/definitions">persistence pair</a> of critical points (see <em><a href="indexd3dd.html?post/Persistence-and-simplification">overview</a></em> section), with its X coordinate being the value at the lowest critical point of the two (i.e. the <em>background</em> density) and its Y coordinate the persitence of the pair (i.e. the value difference between the two, interpreted as <em>contrast</em> of the topological feature it represents with respect to its background). Points located in the right side of this diagram represent features located in high valued regions of the map, while points in the upper side represent features that clearly stand out from their background. More specifically, the green squares stand for pairs of type <em>1</em> (i.e. saddle-point / maximum pairs) while blue disks stand for pairs of type <em>0</em> (i.e. minimum saddle-point pairs). This can be easily visualized on the following image, which represents a zoom on the map with critical points identified as blue squares, green crosses and red triangles for minima, saddle points and maxima respectively.  On this plot, the identified filaments are represented in black, and each persistence pair of type <em>0</em> or <em>1</em>  is represented as a blue or green segment linking its two critical points together (each segment corresponds to one point in the persistence diagram above):
<br /><br />
<img src="../images/m16_skel_nocut_ppairs_crit.png" alt="M16_skel_nocut_ppairs_crit.png" style="display:block; margin:0 auto;" />
<br /><br /></p>


<p>Basically, in 2D, removing a pair of type <em>0</em> (i.e. cancelling two critical points linked by a blue segment) amounts to deleting a piece of filament (i.e. 2 arcs departing from the saddle point) by merging two voids while removing a pair of type <em>1</em> (i.e. cancelling two critical points linked by a green segment) amounts to gluing pieces of filaments into longer ones  (i.e. two arcs departing from the saddle point with one other arc departing from the maximum). When selecting the persistence threshold without à-priori, we therefore want to keep only the pairs that stand out of the general distribution on the Y-axis (i.e. with high persitence) so that only the most significant topological features remain. Selecting a threshold of <em>~4.2E21</em> as shown on the persistence diagram above seems quite reasonable (using <em>Ctrl+left Click</em>, and clicking on the <em>DONE</em> button to proceed).
<br /><br />
<a name="trim_exp"></a>
Visualizing a persistence diagram is a good way to determine the persistence threshold when assuming no previous knowledge of the data set. Note however that persistence could also have been set à-priori to the estimated amplitude of what is considered non-meaningful features or noise with option <em><a href="index4656.html?post/mse#cut">-cut &lt;val&gt;</a></em> instead of <em><a href="index4656.html?post/mse#interactive">-interactive</a></em>. It is nonetheless always useful to check the persistence diagram as it deeply reflects the topological nature of the distribution and can be used to understand it better. For instance, the following diagram (represented by a 2D histogram of the pairs distribution, instead of the pairs themselves) was computed from a totally different map, and it is a good example:
<br /><br />
<img src="../images/ic5146_col_dens_pers_diag.png" alt="ic5146_col_dens_pers_diag.png" style="display:block; margin:0 auto;" />
<br /><br />
Indeed, from this diagram, not only can one learn that the persistence threshold should be <em>~6.E20</em> (from the Y-axis), but one can easily see that the nature of the distribution is different for background values below or above "X=~4E20" on the X-axis. This feature reflects the fact that in some regions of this data-set, the signal was below the instrument detection threshold and the result is complex noise generated by the detectors. Meaningful features may stand out from these regions, so it does not affect the choice of the persistence threshold. However, this tells us that any region with a value <em>&lt;4E20</em> cannot be considered signal and identified filaments should therefore be trimmed wherever the value is below this threshold (this can be achieved by running mse with a persitencce threhold of <em>6.E20</em> and then running the following command on the output skeleton file: <em><a href="index6160.html?post/skelconv#trim">skelconv filaments.NDskl -trimBelow 4.E20</a></em>).
<br /><br />
Let us now come back to  our example, where no such trimming is necessary. Selecting a persistence threshold of <em>~4.2E21</em> as discussed previously, we obtain the following filamentary structures :
<br /><br />
<img src="../images/m16_skel.png" alt="M16_skel.png" style="display:block; margin:0 auto;" />
<br /><br />
Remember that DisPerSE identifies structures as features of the <a href="index959e.html?post/definitions">Morse-Smale complex</a>. The output of <em>mse</em> is <em>always</em> a valid (subset of the) Morse-Smale complex. In particular, filaments are identified as the set of <a href="index959e.html?post/definitions">arcs</a> joining maxima and critical points, which means that pieces of filament always link a maximum and a critical point: they cannot stop in any other point, and whenever two filaments merge in points that are not maxima (i.e. bifurcation point), they remain distinct filaments until they reach a maximum (i.e. although they are not <em>visually</em> distinct as they are infinitely close, they are still stored as separate arcs in the output file). This is illustrated on the following figure,  which shows a zoom on the identified filamentary structures with minima, saddle points and maxima represented as blue squares, green crosses and red triangles respectively:
<br /><br />
<img src="../images/m16_skel_nodes.png" alt="M16_skel_nodes.png" style="display:block; margin:0 auto;" />
<br /><br />
On this figure, individual pieces of filaments (i.e. arcs) link red triangles to green crosses, and several pieces of arcs may therefore overlap above bifurcation points. This is of course desirable for mathematical applications that require the computation of valid Morse-Smale complexes but can be problematic when one only needs to identify structures and measure their properties. Indeed, regions where several arcs overlap may accidentally be given a stronger weight in statistical analysis, biasing the results. One can fix this with the option <em><a href="index6160.html?post/skelconv#breakdown">-breakdown</a></em> of <a href="index6160.html?post/skelconv">skelconv</a> which is used to identify bifurcation points (adding them as dummy critical points of critical index <em>D+1</em>) and break filaments down into individual pieces of arcs.
<br /><br />
Another problem is the resolution of the filaments, which is roughly equal to that of the underlying map: filaments are described as sets of small segments linking neighbor pixels together in the oupout files of <em>mse</em>. As a result, they appear <em>jagged</em> on the previous image and they can locally only take a discrete set of orientation. Using option <em><a href="index6160.html?post/skelconv#smooth">-smooth N</a></em> of <a href="index6160.html?post/skelconv">skelconv</a>, one can fix this by ensuring their <em>smoothness</em> over a size of <em>~N pixels</em>. Note that only individual arcs or pieces of arcs are smoothed when using this option, critical points and bifurcation points remain fixed. As a result, the order of options <em><a href="index6160.html?post/skelconv#smooth">-smooth</a></em> and <em><a href="index6160.html?post/skelconv#breakdown">-breakdown</a></em> on the command line is important.
<br />
We choose to first smooth over  ~6 pixels and then break the network down :
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">skelconv m16_zo_no70um_density.fits_c4.2e+21.up.NDskl -smooth 6 -breakdown</div>


<p><br /><br />
The result is illustrated on the following figure:
<br /><br />
<img src="../images/m16_skelbs_nodes.png" alt="M16_skelBS_nodes.png" style="display:block; margin:0 auto;" />
<br /><br />
where filaments are now smooth and bifurcation points are now identified as yellow discs : pieces of filament now link critical or bifurcation points and therefore do not overlap anymore.
<br /><br />
Although the resulting filaments are perfectly usable as such for analysis, other useful post-treatment are available in DisPerSE. We give in the following an example of their possible usage, but note that it should of course be adapted to the particular results one wants to obtain ...
<br /><br />
Options <em><a href="index6160.html?post/skelconv#trim">-trimAbove</a></em> and <em><a href="index6160.html?post/skelconv#trim">-trimBelow</a></em>  for instance allow trimming portion of arcs so that they do not have to start/stop at critical or bifurcation points (dummy critical nodes are added at their extremities). By default, these options will trim the filaments above or below a given value of the field (see e.g. the example in the <a href="#trim_exp">section</a> on the persistence diagram above), but filaments can also be trimmed in any value tagged within the <a href="index661f.html?post/skeleton-formats">skeleton file</a> (the list of the tags can be displayed by running <em><a href="index6160.html?post/skelconv#info">skelconv filaments.NDskl -info</a></em> and arbitrary tags can be added with option <em><a href="index6160.html?post/skelconv#addfield">-addField</a></em>).
<br /><br /><a name="robustness"></a>
A useful trimming function is <em><a href="index959e.html?post/definitions#robustness">robustness</a></em> or <em>robustness_ratio</em>, which is not tagged by default in the <a href="index661f.html?post/skeleton-formats">skeleton files</a> but can computed using option <em><a href="index4656.html?post/mse#robustness">-robustness</a></em> of <em>mse</em> (you can use option <em><a href="index4656.html?post/mse#loadmsc">-loadMSC</a></em> to avoid recomputing the whole Morse-Smale complex):
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse m16_zo_no70um_density.fits -mask M16_mask.png -cut 4.2E21 -upSkl -loadMSC m16_zo_no70um_density.fits.MSC</div>


<p><br /><br />
Robustness implements an improved version of the concept of <em>separatrix persistence</em> (Weinkauf, T. and Gunther, D., 2009) that allows the extension of regular <em>persistence</em> to each points of the filaments (as opposed to critical points pairs). Running the following command:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">skelconv m16_zo_no70um_density.fits_c4.2e+21.up.NDskl -breakdown -smooth 6 -trimBelow robustness 8E21</div>


<p><br /><br />
one can select the most meaningful subset of the filaments (you can try several robustness thresholds to see the result, but the selected threshold should probably be greater than the persistence threshold). Note that the concepts of persistence and robustness are different, and robustness basically allows selecting those subsets of persistent (topological) filaments that are most prominent. For that reason, it may make sense when trimming on robustness criteria to lower the persistence threshold (in <em>mse</em>) so that the significant pieces of less persistent filaments can still be conserved (you should probably experiment in order to find the best compromise between persistence and robustness thresholds for a given type of data set).
In the present case, choosing a robustness threshold of 8E21 (i.e. slightly higher than the persistence threshold), one obtains the following filaments:
<br /><br />
<img src="../images/m16_skelbst_inc.png" alt="M16_skelBST_inc.png" style="display:block; margin:0 auto;" />
<br /><br /></p>


<p>Another interesting post-treatment is the option <em><a href="index6160.html?post/skelconv#assemble">-assemble</a></em> that allows merging individual aligned pieces of filaments into larger structures. On the following picture, each piece of filament is represented with a distinct color:
<br /><br />
<img src="../images/m16_skelbst_nodes_fil.png" alt="M16_skelBST_nodes_fil.png" style="display:block; margin:0 auto;" />
<br /><br />
Running the following command (note once again that the order of arguments is important, try changing it ...):
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">skelconv m16_zo_no70um_density.fits_c4.2e+21.up.NDskl -breakdown -smooth 6 -trimBelow robustness 1.0E22 -assemble 70</div>


<p><br /><br />
one can assemble pieces of filaments that form an angle smaller than <em>70</em> degrees, resulting in the following structures, where individual pieces are straight but as long as possible:
<br /><br />
<img src="../images/m16_skelbsta_nodes_fil.png" alt="M16_skelBSTA_nodes_fil.png" style="display:block; margin:0 auto;" />
<br /><br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index2d20.html?post/Example-1">Point sample: 2D voids and filaments</a>
   </h2>
      <div class="post-content"><p>This tutorial uses file  <em>${DISPERSE}/data/simu_2D.ND</em> which contains the projected distribution of the particles in a slice of an N-Body dark matter simulation of a <em>50 Mpc</em> large chunk of the universe. Note that although we use a 2D slice for convenience here, the following procedure would also work with the full 3D distribution.
<br />
<br />
In this example, the voids and filaments of the particle distribution will be computed from the underlying density function traced by the particles, so we first need to define the topology of the space (i.e. we need a notion of neighborhood for each particle) and to estimate the density function. This is achieved using the Delaunay tessellation of the particle distribution, which can be computed with <em><a href="index490e.html?post/Usage">delaunay_2D</a></em>.
<br />
<br />
The distribution of the particles is periodic, so we could simply run:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">delaunay_2D simu_2D.ND -periodic</div>


<p><br />
However, in this example we are going to pretend that the distribution has boundaries, which will make visualization easier (if boundary conditions are periodic, a filament crossing a boundary reappears on the other side, causing visual artifacts). We nevertheless would like to use the fact that boundary conditions are indeed periodic to correctly estimate density on the boundaries, which can be achieved using option <em><a href="index490e.html?post/Usage#btype">-btype</a></em>:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">delaunay_2D simu_2D.ND -btype periodic</div>


<p><br />
The output file is named <em>simu_2D.ND.NDnet</em> by default, and it contains the Delauany tessellation as an <a href="index9cca.html?post/networks">unstructured network</a> in <a href="indexceff.html?post/NDnet-format">NDnet</a> format, as well as the density function estimated using DTFE at each vertex (i.e. the additional vertex data labeled <em>field_value</em> in the NDnet file). This file can be fed directly to <a href="index4656.html?post/mse">mse</a>, but we have to choose a persistence threshold first.
<br />
<br />
Because the input file is a Delaunay tessellation, persistence is expressed as a ratio (density has a close to lognormal PDF) and the persistence threshold as a <em>number of sigmas</em> representing the probability that a persistence pair with given persistence ratio happens in a pure random discrete Poisson distribution. It is usually safe in such case to select a threshold between 2-sigmas and 4-sigmas, and we could directly compute the filaments of the distribution with the following command (see <a href="index4656.html?post/mse">mse</a> for more info):
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_2D.ND.NDnet -nsig 3 -upSkl</div>


<p><br />
However, in this example, we will use a persistence diagram to decide the correct threshold (in case you do not have <a href="index8707.html?post/pdview">pdview</a>, replace <em><a href="index4656.html?post/mse#interactive">-interactive</a></em> with <em><a href="index4656.html?post/mse#nsig">-nsig 3</a></em> in the following commannd) and we would also like to identify the voids in the distribution (i.e. the ascending 3-manifolds originating from critical points of critical index 0; see option <em><a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a></em> of <a href="index4656.html?post/mse">mse</a>):
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_2D.ND.NDnet -interactive -upSkl -dumpManifolds J0a</div>


<p><br />
After running this command line, you should be able to visualize the following diagrams:
<br /><br />
<img src="../images/per_diag_small.jpg" alt="per_diag_small.jpg" style="display:block; margin:0 auto;" />
<br />
On this picture, the maxima/saddle persistence pairs diagram is represented on the left and the minima/saddle one on the right. The fact that the second type of pairs are clearly less persistent reflects the known fact that dark matter haloes are very prominent structures because they belong to regions in the non linear regime where density increases exponentially fast. One nice feature of persistence diagrams is that they make it easy to choose the threshold above which underlying topological structures stand out of the noise : in the present case, we want to select the high persistence tails only that clearly stand out from the bunch of pairs generated by noise. This gives us a threshold of around <em>3-sigmas</em> that can be visually selected by clicking while holding <em>Ctrl</em> key down. Once the threshold is selected, simply press <em>Done</em> button.
<br />
<br />
After this operation, <a href="index4656.html?post/mse">mse</a> should output two files: the filaments in a <a href="index661f.html?post/skeleton-formats">skeleton type</a> file (<em>simu_2D.ND.NDnet_s3.up.NDskl</em>) and the voids in a <a href="index9cca.html?post/networks">network type</a> file (<em>simu_2D.ND.NDnet_s3_manifolds_J0a.NDnet</em>).
<br />
<br />
By default, <em>mse</em> associates maxima to vertices while minima are associated to d-<a href="index959e.html?post/definitions">simplices</a> (where d is the dimension of space). As a result, the network representing the voids defines a set of triangles each associated to a given void. This may not be very practical for post-treatment or visualization, but we can use option <em><a href="index4656.html?post/mse#vertexasminima">-vertexAsMinima</a></em> to reverse the convention (this will overwrite the previous file if the threshold is identical):
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_2D.ND.NDnet -nsig 3 -vertexAsMinima -dumpManifolds J0a</div>


<p><br />
We can now visualize the result by converting the files to vtk formats using <a href="index6160.html?post/skelconv">skelconv</a> and <a href="index25e8.html?post/netconv">netconv</a>. The skeleton is smoothed and converted to <em><a href="indexb3eb.html?post/vtk-formats">vtp</a></em> format:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">skelconv simu_2D.ND.NDnet_s3.up.NDskl -smooth 10 -to vtp</div>


<p><br />
and the input tesselation and output voids are converted to <em><a href="indexe8f9.html?post/vtk-network-format">vtu</a></em> format:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">
netconv simu_2D.ND.NDnet_s3_manifolds_J0a.NDnet -to vtu</br>
netconv simu_2D.ND.NDnet -to vtu
</div>


<p><br /><a name="voids"></a>
the result should look as follows when visualized with <em><a href="http://www.paraview.org/" title="paraview">paraview</a></em>: (the configuration file <em>${DISPERSE}/data/simu_2D_nonper.pvsm</em> can be directly loaded in paraview (<em>File-&gt;Load State</em>) to produce the following plot)
<br /><br />
<img src="../images/simu_2d_tuto_small.jpg" alt="simu_2D_tuto_small.jpg" style="display:block; margin:0 auto;" />
<br /><br />
<strong>Note</strong>: on the right figure, a different color is associated to the <em><a href="index9cca.html?post/networks#source">source_index</a></em> of each particle depending on which void it belongs to: each void originates from a different minimum of the field and each critical point has a specific index. This <em>source_index</em> corresponds to the  position of this critical point as a node in skeleton files or as a vertex in persistence pair networks obtained with <a href="index4656.html?post/mse">mse</a> (options <em><a href="index4656.html?post/mse#dumparcs">-dumpArcs</a></em> and <em><a href="index4656.html?post/mse#ppairs">-ppairs</a></em>). It can therefore also be used to cross-link information contained in manifold networks and skeletons or persistence pairs, such as for instance retrieving the hierarchy of the voids (i.e. using the <em><a href="index9cca.html?post/networks#parent">parent_index</a></em> of the critical points in <a href="index661f.html?post/skeleton-formats#parent">skeleton files</a> and persistence pairs networks).</p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexf6f1.html?post/Example-2">Point sample: 3D walls and filaments</a>
   </h2>
      <div class="post-content"><p>This tutorial follows the 2D discrete case example introduced in the <a href="index2d20.html?post/Example-1">previous section</a> so you should probably read it first if you haven't done so yet.
<br /><br />
We will compute the filaments and walls from the downsampled dark matter N-body simulation snapshot <em>${DISPERSE}/data/simu_32_id.gad</em>. The distribution has periodic boundary conditions and we therefore start by computing its Delaunay tessellation with the following command:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">delaunay_3D simu_32_id.gad -periodic</div>


<p><br />
The program should output a file called <em>simu_32_id.gad.NDnet</em> that can be used directly with <a href="index4656.html?post/mse">mse</a> to compute the filaments and walls of the distribution. In 3D, walls are represented by the <a href="index959e.html?post/definitions">ascending 2-manifolds</a> that originate from critical points of critical index <em>1</em> so they can be computed with option <em><a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a> JE1a</em> (letter <em>E</em> stands for <em>Extended</em>, which means that the ascending 1-manifolds and ascending 0-manifolds  at the boundary of the walls will also be added, see option <em><a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a></em> of <a href="index4656.html?post/mse">mse</a>) .Note that by default, subsets of the walls that are common to several walls are merged together, so you may want to try <em>-dumpManifolds JP1a</em> instead if you are interested in studying the properties of individual walls. The filaments are computed with option <em><a href="index4656.html?post/mse#upskl">-upSkl</a></em> or <em><a href="index4656.html?post/mse#dumparcs">-dumparcs</a> U</em> which are equivalent. Using interactive mode to select a persistence threshold (use <em><a href="index4656.html?post/mse#nsig">-nsig</a> 3.5</em> instead of <em><a href="index4656.html?post/mse#interactive">-interactive</a></em> if <a href="index8707.html?post/pdview">pdview</a> could not compile on your computer), we run the following command:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_32_id.gad.NDnet -dumpManifolds JE1a -upSkl -interactive</div>


<p><br />
which after some quick computations, should display the following persistence diagram.
<br /><br />
<img src="../images/per_diag_3d.jpg" alt="per_diag_3D.jpg" style="display:block; margin:0 auto;" />
<br />
On this diagram, each type of pair is represented by a mark of different color : blue for minima/1-saddle, green for 1-saddle/2-saddle and red for 2-saddle/maxima. Note that the blue dots in the lower left corner stand for the voids in the distribution, so it is expected that we find only few of them compared to the red dots which represent collapsed structure (the simulation is <em>50 Mpc</em> large). Each point on the diagram representing a topological feature, we would like to select only those points that stand out of the general distribution in terms of persistence in order to keep only the most meaningful structures (the persistence selection threshold is set by clicking while holding <em>Ctrl</em> key). The diagram suggests that persistence threshold should be above <em>~3-sigmas</em> so we select a threshold of <em>~3.5 sigmas</em> and click on the <em>done</em> button to confirm the selection. The program continues and should output the filaments in file <em>simu_32_id.gad.NDnet_s3.52.up.NDskl</em> and the walls in file <em>simu_32_id.gad.NDnet_s3.52_manifolds_JE1a.NDnet</em>.
<br /><br />
It is instructive at that point to read <a href="index4656.html?post/mse">mse</a> output, and in particular the following section :
<br /><br /></p>

<pre>****** Simplifying complex ******
Starting Morse-Smale complex simplification.
Computing persistence pairs ... SKIPPED.
Sampling noise level was set to 3.5-sigma.
Cancelling pairs with persistance ratio &lt; [2.66e+00,3.14e+00,4.42e+01].
   Tagging arcs ... done.
   Cancelling pairs (smart) ... (4140 rem.)
done.
   Cancellation took 0.10s (4140 canceled, 1 conflicts, 10 loops).</pre>

<p><br /></p>


<p>what <em>mse</em> tells us here is that it successfully removed <em>4140</em> persistence pairs, but was not able to cancel <em>11</em> more although their persistence was lower than the threshold. The <em>10 loops</em> represent persistence pairs that were connected by more than one arc at the moment of their cancellation. Topologically speaking, their cancellation is not a valid operation as it would result in a discrete gradient loop (integral lines cannot form loops in <a href="index1f6e.html?post/general-concepts">Morse-theory</a>). Note that the existence of non-cancellable pairs is not a bug of DisPerSE but rather a feature of Morse theory. However, not cancelling them may result in a few spurious non-significant pieces of filaments remaining in the ouput file (this is very problematic though as the impact on the identified filaments is very small in general) so one can use option <em><a href="index4656.html?post/mse#forceloops">-forceLoops</a></em> to remove them anyway (which is perfectly fine if your goal is only to identify structures). Using this option will also solve the <em>1 conflict</em> identified by mse, as conflicts are the result of a non-cancellable pair blocking the cancellation of a valid cancellable pair.
<br /><br />
We can now rerun <em>mse</em> while skipping the computations by loading the backup file <em>simu_32_id.gad.NDnet.MSC</em> that mse generated on the previous run with option <em><a href="index4656.html?post/mse#loadmsc">-loadMSC</a></em>:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_32_id.gad.NDnet -dumpManifolds JE1a -upSkl -forceLoops -loadMSC simu_32_id.gad.NDnet.MSC  -nsig 3.52</div>


<p><br />
and the ouput should contain the following line:
<br /><br /></p>

<pre>   Cancellation took 0.10s (4151 canceled, 0 conflicts, 11 forced loops).</pre>

<p><br />
indicating that all the <em>4151</em> non persistent pairs could be cancelled.
<br /><br />
We can now smooth and convert the resulting files to a more portable format:
<br /><br /></p>

<pre>skelconv simu_32_id.gad.NDnet_s3.52.up.NDskl -smooth 10 -to vtp
netconv simu_32_id.gad.NDnet -to vtu
netconv simu_32_id.gad.NDnet_s3.52_manifolds_JE1a.NDnet -smooth 10 -to vtu</pre>

<p><br /><a name="walls"></a>
and visualize the result with <a href="http://www.paraview.org/" title="paraview">paraview</a>. The configuration file <em>${DISPERSE}/data/simu_32_per.pvsm</em> can be directly loaded in paraview (<em>File-&gt;Load State</em>) to make the following plot: (note that it is a bit tricky to deal with periodic boundary conditions when visualizing, clipping the boundaries is usually the easiest way)
<br /><br />
<img src="../images/simu_3d_result_small.jpg" alt="simu_3D_result_small.jpg" style="display:block; margin:0 auto;" />
<br /><br />
<strong>Note</strong>: contrary to the previous example where we computed 2D voids (see <a href="index2d20.html?post/Example-1#voids">here</a>), it is problematic in this case to identify each individual wall and paint it with a specific color. Indeed, contrary to voids, the 2-manifolds that represent walls can overlap, and so a unique <em><a href="index9cca.html?post/networks#source">source_index</a></em> representing the critical point from which each wall originates cannot be assigned to each simplex (i.e. in that case, triangle). A solution to this problem would have been to specify that we wanted identical simplices to be stored as many times as they appear in different walls even though they are the same. This could have been achieved with flag <em>P</em> of option <em><a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a></em> in <em>mse</em>:
<br /><br /></p>
<div style="text-align: center; border: 1px dotted gray;">mse simu_32_id.gad.NDnet -dumpManifolds JEP1a -upSkl -forceLoops -loadMSC simu_32_id.gad.NDnet.MSC  -nsig 3.52</div>


<p><br />
As a result, the output file is larger, but it would also allow cross-linking the information contained in the geometry of the walls and that in the skeleton files or persistence pairs network (see this <a href="index2d20.html?post/Example-1#voids">note</a>).</p></div>
   

  

 <h2 class="category-title">
 <a href="index3333.html?category/Skeleton-I-O">Skeleton data</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index661f.html?post/skeleton-formats">Skeleton files</a>
   </h2>
      <div class="post-content"><p>This file type is designed to store the critical points and arcs of the Morse-Smale complex (i.e. one dimensionnal filamentary structures). In skeleton files, the filamentary network is described as lists of nodes representing critical points or bifurcation points if available (see option <em><a href="index6160.html?post/skelconv#breakdown">-breakdown</a></em> of <a href="index6160.html?post/skelconv">skelconv</a>), lists of segments tracing the local geometry of arcs and filaments originating from and leading to nodes and described as lists of segments. The base skeleton format is <a href="indexf83e.html?post/NDskl-format">NDskl</a> which is used internally, but this format may be converted to several other more or less complex formats of skeleton files adapted to different applications (see option <em><a href="index6160.html?post/skelconv#to">-to</a></em> in program <a href="index6160.html?post/skelconv">skelconv</a>, a list of available formats is displayed when running the program without argument).<br />
<ins>nb</ins>: Within skeleton files, the segments are always oriented in the ascending direction of the arcs, which does *NOT* necessarily mean that the value of the field is necessarily increasing locally ! Indeed, the value is locally allowed to fluctuate within the persistence threshold, so the field value does not have to be strictly increasing locally along an arc.
<br />
<br />
<strong><ins>Available formats</ins></strong>:
<br />
<br /></p>
<ul>
<li>-<strong><a href="indexf83e.html?post/NDskl-format">NDskl</a></strong> (Read / Write):<br /> This is the format of the skeleton files created with <a href="index4656.html?post/mse">mse</a>. It is a relatively complex binary format that contains all the information on the geometry and connectivity of the arcs of the Morse-Smale complex (i.e. filaments).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexbea5.html?post/NDskl_ascii-format">NDskl_ascii</a></strong> (Write only):<br /> This ASCII format contains the same amount of information as <em>NDskl</em> files, but organized in a different way. In particular, filaments are not described as lists of segments but rather each filament is described by an origin node, a destination node, and a set of sampling points.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexfe47.html?post/segs_ascii-format">segs_ascii</a></strong> and <strong><a href="index083b.html?post/crits_ascii-format">crits_ascii</a></strong> (Write only):<br /> This is a simplified ASCII file format designed to be easily readable but that only contains a subset of the information available in <em>NDskl</em> files. In particular, <em>segs_ascii</em> files contain a list of individual segments describing the local orientation of the arcs as well as some limited information on the filament they belong to, while <em>crits_ascii</em> contain information on the critical points and bifurcation points only.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexb3eb.html?post/vtk-formats">vtk</a></strong>, <strong><a href="indexb3eb.html?post/vtk-formats">vtk_ascii</a></strong>, <strong><a href="indexb3eb.html?post/vtk-formats">vtp</a></strong> and <strong><a href="indexb3eb.html?post/vtk-formats">vtp_ascii</a></strong> (Write only):<br /> These formats are binary and ASCII legacy and XML <a href="http://www.vtk.org/">VTK</a> formats that are readable by several 3D visualization tools, such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a> for instance.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="index9cca.html?post/networks">NDnet</a></strong> (Write only):<br /> Using this format, skeleton files can be converted to <a href="index9cca.html?post/networks">unstructured networks</a> (use <em><a href="index25e8.html?post/netconv">netconv</a></em> to convert <em>NDnet</em> files to other network formats).</li>
</ul>
<p><br />
<br />
<strong><ins>Additional data</ins></strong>: In addition to the topology and geometry of filamentary structures, more complete formats (i.e. <a href="indexf83e.html?post/NDskl-format">NDskl</a>, <a href="indexbea5.html?post/NDskl_ascii-format">NDskl_ascii</a> and all <a href="indexb3eb.html?post/vtk-formats">vtk</a> formats) may store arbitrary additional information associated to filaments and nodes that can be used by <em><a href="index6160.html?post/skelconv">skelconv</a></em> (run <em>skelconv filename.NDskl -info</em> for a list of additional data available in skeleton file <em>filename.NDskl</em>). By default, <a href="index4656.html?post/mse">mse</a> stores the following additional data in skeleton type files:
<br />
<br /></p>
<ul>
<li>-<strong>persistence</strong> / <strong>persistence_ratio</strong> / <strong>persistence_nsigmas</strong> (Nodes only) :<br /> The persistence (expressed as a difference, ratio or in <em>number of sigmas</em>) of the persistence pair containing the corresponding critical point. A negative or null value indicates that the node is not a critical point or that it does not belong to a persistence pair.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>persistence_pair</strong> (Nodes only):<br /> The index of the node that corresponds to the other critical point in the persistence pair (indices start at 0). The value is the index of the current node itself when it is not a critical point or it does not belong to a persistence pair.</li>
</ul>
<p><br /><a name="parent"></a></p>
<ul>
<li>-<strong>parent_index</strong> / <strong>parent_log_index</strong> (Nodes only):<br /> For each extrema only (i.e. minima and maxima), the index of the node that corresponds to the other extremum into which it would be merged if its persistence pair was canceled (indices start at 0). This can be used to reconstruct the tree of the hierarchy of maxima and minima. The value is -1 for non extrema critical points. The difference between the two versions is that the second (<em>parent_log_index</em>) is the hierarchy computed from the logarithm of the field. This second version is useful only for discrete point samples whose MS-complex is obtained from the delaunay tessellation computed with <em><a href="index490e.html?post/Usage">delaunay_nD</a></em>. Practically, <em>parent_log_index</em> can be used whenever persistence pairs are cancelled in order of increasing ratio (option <em><a href="index4656.html?post/mse#nsig">-nsig</a></em> in <em>mse</em>), and <em>parent_index</em> whenever persistence pairs are cancelled in order of increasing difference  (option <em><a href="index4656.html?post/mse#cut">-cut</a></em> in <em>mse</em>).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>field_value</strong> / <strong>log_field_value</strong> (Nodes and Segments) :<br /> The value of the field and it logarithm. For segments, the suffix <em>_p1</em> and <em>_p2</em> is added to indicate which extremity of the segment it corresponds to.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>cell</strong> (Nodes and Segments) :<br /> The <em>type</em> and <em>index</em> of the cell corresponding to the node / segment in the initial network (i.e. from which the skeleton was computed). For segments, the suffix <em>_p1</em> and <em>_p2</em> is added to indicate which extremity of the segment it corresponds to. The value is a double precision floating number whose integer part is the index of the cell and decimal part its type. For instance, the 156th vertex (i.e. 0-cell) in the cell complex is represented as 156.0, while the 123th tetrahedron is 123.3. Note that the index of the 0-cell correpond to the index of the pixel / vertices in the original network from which the skeleton was computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>robustness</strong> / <strong>robustness_ratio</strong> (Nodes and Segments) :<br /> The robustness of the node / segment. Robustness is a local measure of how contrasted the critical point / filament is with respect to its <em>local</em> background, and it is therefore a good way to select only highly contrasted subsets of the filamentary structures (see option <em><a href="index6160.html?post/skelconv#trim">-trimBelow</a></em>  in <em><a href="index6160.html?post/skelconv">skelconv</a></em>). Note that robustness, like persistence, is defined as a difference or ratio between the value of the field in two points, so the robustness threshold has the same order of magnitude as the persistence threshold.</li>
</ul>
<p><br /></p>
<ul>
<li>- <strong>type</strong> (Segments only) :<br /> The type of arc the segment belongs to. The value corresponds to the lowest critical index of the two critical points at the extremities of the arc the segments belongs to. For instance, in dimension D, the ridges (filaments) have type <em>D-1</em>.</li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexf83e.html?post/NDskl-format">NDskl format</a>
   </h2>
      <div class="post-content"><p>This is the native binary format of DisPerSE. Functions for reading and writing <em>NDskl</em> format  in <em>C</em> can be found within the file <code>${DISPERSE_SRC}/src/C/NDskeleton.c</code> (see functions <em>Load_NDskel</em>, <em>Save_NDskel</em> and also <em>Create_NDskel</em>). In this format, the arcs of the Morse-Smale complex are described as arrays of nodes and segments with data associated to each of them. Each node contains information on critical points (which may also be bifurcations points or trimmed extremities of filaments). Each segment contains information on the local geometry of the arcs and global properties of the skeleton.
<br />
<br />
When using the C functions from Disperse, data is loaded into the following <em>C</em> structure which is close to the actual structure of the file (see file <code>${DISPERSE_SRC}/src/C/NDskeleton.h</code>):</p>


<pre>struct NDskl_seg_str {
   int nodes[2];  // index of the nodes at the extremity of the arc. Segment is oriented from nodes[0] toward nodes[1]
   float *pos;  // points to appropriate location in segpos
   int flags;  // non null if on boundary 
   int index;  // index of the segment in the Seg array
   double *data;  // points to the nsegdata supplementary data for this segment
   struct NDskl_seg_str *Next; // points to next segment in the arc, NULL if extremity (-&gt;connects to nodes[1])
   struct NDskl_seg_str *Prev; // points to previous segment in the arc, NULL if extremity (-&gt;connects to nodes[0])
 }; 
 typedef struct NDskl_seg_str NDskl_seg;</pre>


<pre> struct NDskl_node_str {
   float *pos;  // points to appropriate location in nodepos
   int flags;  // non null if on boundary 
   int nnext;  // number of arcs connected
   int type;  // critical index
   int index;  // index of the node in the Node array
   int *nsegs; // number pf segments in each of the the nnext arcs
   double *data;   // points to the nnodedata supplementary data for this segment
   struct NDskl_node_str **Next;  // points to the node at the other extremity of each of the nnext arcs
   struct NDskl_seg_str **Seg;   // points to the first segment in the arcs, starting from current node.
 }; 
 typedef struct NDskl_node_str NDskl_node;</pre>


<pre> typedef struct NDskel_str {
   char comment[80];
   
   int ndims;  // number of dimensions
   int *dims;  // dimension of the underlying grid, only meaningfull when computed from a regular grid
   double *x0;  // origin of the bounding box
   double *delta;  // dimension of the bounding box
    
   int nsegs;  // number of segments
   int nnodes;  // number of nodes
   
   int nsegdata;  // number of additional data for segments
   int nnodedata;  // number of additional data for nodes
   char **segdata_info;  // name of additional fields for segments
   char **nodedata_info;  // name of additional fields for nodes
   
   float *segpos;  // positions of the extremities of segments (2xndims coords for each segment)
   float *nodepos; // positions of the nodes (ndims coords for each segment)
   double *segdata; // additional data for segments (nsegs times nsegdata consecutive values)
   double *nodedata; // additional data for nodes (nnodes times nnodedata consecutive values)
   
   NDskl_seg *Seg;  // segment array (contains all segs)
   NDskl_node *Node;  // nodes array (contains all nodes)
 } NDskel;</pre>

<p><br />
<br />
The <em>NDskl</em> binary format is organized as follows (blocks are delimited by <em>dummy</em> variables indicating the size of the blocks for FORTRAN compatibility, but they are ignored in C):
<br />
<br /></p>
<table style="margin: 1em auto 1em auto"><caption>NDskl binary format</caption><tr  valign="top"><td width="10%">field</td><td width="10%">type</td><td width="10%">size</td><td width="65%">comment</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> for FORTRAN compatibility</td></tr>
<tr  valign="top"><td>tag</td><td>char(1B)</td><td>16</td><td>identifies the file type. Value : "NDSKEL"</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>comment</td><td>char(1B)</td><td>80</td><td>a comment on the file (string)</td></tr>
<tr  valign="top"><td>ndims</td><td>int(4B)</td><td>1</td><td>number of dimensions</td></tr>
<tr  valign="top"><td>dims</td><td>int(4B)</td><td>20</td><td>dimension of underlying grid (0=none, ndims values are read)</td></tr>
<tr  valign="top"><td>x0</td><td>double(8B)</td><td>20</td><td>origin of bounding box (ndims first values are meaningful)</td></tr>
<tr  valign="top"><td>delta</td><td>double(8B)</td><td>20</td><td>size of bounding box (ndims first values are meaningful)</td></tr>
<tr  valign="top"><td>nsegs</td><td>int(4B)</td><td>1</td><td>number of segments</td></tr>
<tr  valign="top"><td>nnodes</td><td>int(4B)</td><td>1</td><td>number of nodes</td></tr>
<tr  valign="top"><td>nsegdata</td><td>int(4B)</td><td>1</td><td>number of additional data associated to segments.</td></tr>
<tr  valign="top"><td>nnodedata</td><td>int(4B)</td><td>1</td><td>number of additional data associated to nodes.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey">  this block is ommited if nsegdata=0</td></tr>
<tr  valign="top"><td>seg_data_info</td><td>char(1B)</td><td>20&timesnsegdata</td><td>name of the segment data field</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> this block is ommited if nsegdata=0</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey">  this block is ommited if nnodedata=0</td></tr>
<tr  valign="top"><td>node_data_info</td><td>char(1B)</td><td>20&timesnnodedata</td><td>name of the node data field</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey">  this block is ommited if nnodedata=0</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>segpos</td><td>float(4B)</td><td>2&timesnsegs&timesndims</td><td>coordinates of segment extremities</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>nodepos</td><td>float(4B)</td><td>nnodes&timesndims</td><td>coordinates of nodes</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>segdata</td><td>double(8B)</td><td>nsegdata&timesnsegs</td><td>value of the segments data fields</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>nodedata</td><td>double(8B)</td><td>nnodedata&timesnnodes</td><td>value of the nodes data fields</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:red"> following block is repeated for each node (&timesnnodes).</td></tr>
<tr  valign="top"><td>pos_index</td><td>int(4B)</td><td>1</td><td>index in the nodepos/nodedata arrays</td></tr>
<tr  valign="top"><td>flags</td><td>int(4B)</td><td>1</td><td>flags (identify boundary nodes)</td></tr>
<tr  valign="top"><td>nnext</td><td>int(4B)</td><td>1</td><td>number of connected arcs</td></tr>
<tr  valign="top"><td>type</td><td>int(4B)</td><td>1</td><td>critical index (ndims+1 for bifurcations / trimmed arc axtremity)</td></tr>
<tr  valign="top"><td>index</td><td>int(4B)</td><td>1</td><td>index of this node</td></tr>
<tr  valign="top"><td>nsegs</td><td>int(4B)</td><td>nnext</td><td>number of segments in each connected arc</td></tr>
<tr  valign="top"><td> * </td><td>*</td><td>*</td><td  style="background:red">blue section repeated for each connected arc (&timesnnext)</td></tr>
<tr  valign="top"><td>nextNode</td><td>int(4B)</td><td>1</td><td style="background:lightblue">index of the other node of the arc</td></tr>
<tr  valign="top"><td>nextSeg</td><td>int(4B)</td><td>1</td><td style="background:lightblue">index of the first segment on the arc</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:red"> following block is repeated for each segment (&timesnsegs).</td></tr>
<tr  valign="top"><td>pos_index</td><td>int(4B)</td><td>1</td><td>index in the segpos/segdata arrays</td></tr>
<tr  valign="top"><td>nodes</td><td>int(4B)</td><td>2</td><td>index of the 2 nodes at the endpoints of the current arc.</td></tr>
<tr  valign="top"><td>flags</td><td>int(4B)</td><td>1</td><td>flags (identify boundary nodes)</td></tr>
<tr  valign="top"><td>index</td><td>int(4B)</td><td>1</td><td>index of this segment</td></tr>
<tr  valign="top"><td>next_seg</td><td>int(4B)</td><td>1</td><td>index of the next segment in the node (-1 if none)</td></tr>
<tr  valign="top"><td>prev_seg</td><td>int(4B)</td><td>1</td><td>index of the previous segment in the node (-1 if none)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexbea5.html?post/NDskl_ascii-format">NDskl_ascii format</a>
   </h2>
      <div class="post-content"><p>An ASCII format that contains the same amount of information as <a href="indexf83e.html?post/NDskl-format">NDskl</a> files, but organized in a different way. In particular, filaments are not described as lists of segments but rather each filament is described by an origin node, a destination node, and a set of sampling points.
<br />
<br /></p>
<table border="1"><caption> NDskl_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> ANDSKEL</th><td> header</td></tr>
<tr  valign="top"><th> ndims</th><td> the number of dimensions</td></tr>
<tr  valign="top"><th> #comments go here</th><td> OPTIONAL: should start with '#' if present (the 80 first characters are read and stored).</td></tr>
<tr  valign="top"><th> BBOX [x0_1 .. x0_d] [delta_1 .. delta_d]</th><td> OPTIONAL: the bounding box, defined by the 'ndims' coordinates of the origin 'x0' and extent 'delta'.</td></tr>
<tr  valign="top"><th> [CRITICAL POINTS]</th><td> Marks the beginning of the critical points section</td></tr>
<tr  valign="top"><th> ncrit</th><td> The number of critical points (CP)</td></tr>
<tr  valign="top"><th> type pos[0] ... pos[ndims-1] value pairID boundary</th><td style="background:lightblue"> Info on the first CP: critical index, position, value, index of CP in the persistence pair, 0 if not on the boundary</td></tr>
<tr  valign="top"><th> nfil</th><td style="background:lightblue"> The number of filaments connected to this CP</td></tr>
<tr  valign="top"><th> destId[0] filId[0]</th><td style="background:lightblue"> Info on the first filament: index of the CP at the other extremity of the filament, and index of the filament (see filaments table below)</td></tr>
<tr  valign="top"><th> ...</th><td style="background:lightblue"> One line for each filament connecting on the CP</td></tr>
<tr  valign="top"><th> destId[nfil-1] filId[nfil-1]</th><td style="background:lightblue"> Information on the last filament</td></tr>
<tr  valign="top"><th  style="background:red">.....</th><td  style="background:red"></td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"> one blue block for each CP.</td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"></td></tr>
<tr  valign="top"><th> [FILAMENTS]</th><td> Marks the beginning of the filaments section</td></tr>
<tr  valign="top"><th> nfil</th><td> Total number of filaments</td></tr>
<tr  valign="top"><th> CP1 CP2 nSamp</th><td style="background:lightblue"> index of the CP at the extremity of the first filament and number of sampling points</td></tr>
<tr  valign="top"><th> P[0][0] ... P[0][ndims-1]</th><td  style="background:lightblue">position of the first sampling point of first filament.</td></tr>
<tr  valign="top"><th> ...</th><td  style="background:lightblue">One line for each sampling point of first filament.</td></tr>
<tr  valign="top"><th> P[nSamp-1][0] ... P[nSamp-1][ndims-1]</th><td  style="background:lightblue">Position of the last sampling point</td></tr>
<tr  valign="top"><th  style="background:red">.....</th><td  style="background:red"></td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"> one blue block for each filament.</td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"></td></tr>
<tr  valign="top"><th> [CRITICAL POINTS DATA]</th><td> Marks the beginning of the CP data section</td></tr>
<tr  valign="top"><th> NF</th><td> Number of fields associated to each CP.</td></tr>
<tr  valign="top"><th> CP_DATA_FIELD_NAME_1</th><td> Name of the first field</td></tr>
<tr  valign="top"><th> ...</th><td></td></tr>
<tr  valign="top"><th> CP_DATA_FIELD_NAME_NF</th><td> Name of the last field</td></tr>
<tr  valign="top"><th> val_1[0] ... val_NF[0]</th><td> Value of each field for first CP</td></tr>
<tr  valign="top"><th> ...</th><td></td></tr>
<tr  valign="top"><th> val_1[N_CP-1] ... val_NF[N_CP-1]</th><td> Value of each field for last CP</td></tr>
<tr  valign="top"><th> [FILAMENTS DATA]</th><td> Marks the beginning of the filaments data section</td></tr>
<tr  valign="top"><th> NF</th><td> Number of fields associated to each sampling point of each filament.</td></tr>
<tr  valign="top"><th> FIL_DATA_FIELD_NAME_1</th><td> Name of the first field</td></tr>
<tr  valign="top"><th> ...</th><td></td></tr>
<tr  valign="top"><th> FIL_DATA_FIELD_NAME_NF</th><td> Name of the last field</td></tr>
<tr  valign="top"><th> val_1[0][0] ... val_NF[0][0]</th><td style="background:lightblue"> field values for first sampling point, first filament</td></tr>
<tr  valign="top"><th> ...</th><td style="background:lightblue"></td></tr>
<tr  valign="top"><th> val_1[0][nSamp[0]] ... val_NF[0][nSamp[0]]</th><td style="background:lightblue"> field values for last sampling point, first filament</td></tr>
<tr  valign="top"><th  style="background:red">.....</th><td  style="background:red"></td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"> one blue block for each filament.</td></tr>
<tr  valign="top"><th style="background:red"> .....</th><td style="background:red"></td></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexfe47.html?post/segs_ascii-format">segs_ascii format</a>
   </h2>
      <div class="post-content"><p>This ASCII format is a very simple one. It consists in a list of individual segments describing the local orientation of the arcs as well as some limited information on the filament they belong. This may be used for doing statistical analysis of local properties of filaments such as the local orientation of a magnetic field for instance. Note that all the segments are oriented from the lower critical index extremity of the filament they belong toward the other extremity (which does NOT mean that the value is strictly increasing, as local fluctuations of amplitude the persistence threshold are still allowed ... ).
<br />
<ins><strong>nb</strong></ins>: you probably want to use option <em><a href="index6160.html?post/skelconv#breakdown">-breakdown</a></em> of <em><a href="index6160.html?post/skelconv">skelconv</a></em> before using this format.
<br />
<br /></p>
<table border="1"><caption> segs_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> #arc segments</th><td> Header</td></tr>
<tr  valign="top"><th> #U0 U1 U2 V0 V1 V2 value_U value_V type boundary</th><td> Header identifying each column</td></tr>
<tr  valign="top"><th> #NDIMS NSEGS</th><td> Number of dimensions and number of segments</td></tr>
<tr  valign="top"><th> U0 U1 U2 V0 V1 V2 value_U value_V type boundary</th><td> The value of the fields for the first segment</td></tr>
<tr  valign="top"><th> ....</th><td> One such line for each NSEGS segment</td></tr>
</table>

<p><br />
<br />
<ins>Notations</ins>:</p>
<ul>
<li>-<strong>U_0</strong>,..., <strong>U_ndims</strong> : The coordinates of the first extremity of the segment. It is the one closest to the lowest critical index CP along the filament it belongs to.</li>
<li>-<strong>V_0</strong>,..., <strong>V_ndims</strong> : The coordinates of the second extremity of the segment. It is the one closest to the highest critical index CP along the filament it belongs to.</li>
<li>-<strong>value_U</strong>, <strong>value_V</strong> : Value of the field in U and V.</li>
<li>-<strong>type</strong> : the type of arc the segment belongs to. The type of an arc is the minimum critical index of the CP at the extremity of the filament the segment belong to.</li>
<li>-<strong>boundary</strong> : value can be <em>0</em>, <em>1</em> or <em>2</em> when the segment is inside the domain, on the boundary, or outside (e.g. at infinity)</li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index083b.html?post/crits_ascii-format">crits_ascii format</a>
   </h2>
      <div class="post-content"><p>This ASCII format is a very simple one. It consists in a list of all the critical points with some useful information for each of them.
<br />
<br /></p>
<table border="1"><caption> crits_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> #critical points</th><td> Header</td></tr>
<tr  valign="top"><th> #X0 X1 X2 value type pair_id boundary</th><td> Header identifying each column</td></tr>
<tr  valign="top"><th> #NDIMS NPOINTS</th><td> Number of dimensions and number of points</td></tr>
<tr  valign="top"><th> X0 X1 X2 value type pair_id boundary</th><td> The value of the fields for the first point</td></tr>
<tr  valign="top"><th> ....</th><td> One such line for each NPOINTS points</td></tr>
</table>

<p><br />
<br />
<ins>Notations</ins>:</p>
<ul>
<li>-<strong>X_0</strong>,..., <strong>X_ndims</strong> : the coordinates of the pooint</li>
<li>-<strong>value</strong> : Value of the field.</li>
<li>-<strong>type</strong> : the critical index of the point. A value of NDIMS+1 indicates a bifurcation point or a trimmed extremity.</li>
<li>-<strong>pair_id</strong> : index of the other critical point in the persistence pair. C style convention is used, indices starting at 0, and points without perisstence pairs have their own index for <em>pair_id</em>.</li>
<li>-<strong>boundary</strong> : value can be <em>0</em>, <em>1</em> or <em>2</em> when the point is inside the domain, on the boundary, or outside (e.g. at infinity)</li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexb3eb.html?post/vtk-formats">vtk skeleton formats</a>
   </h2>
      <div class="post-content"><p>VTK formats are developed for the Visualization Tool Kit library (<a href="indexb3eb.html?post/vtk-formats">VTK</a>) and can be used for 3D visualization with software such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a>. Skeletons are stored as <em>VTK polygon data</em> and can be output in fours different VTK formats:
<br /><br /></p>
<ul>
<li>-<strong>vtk</strong>: the legacy format</li>
<li>-<strong>vtk_ascii</strong>: ASCII version of the vtk format</li>
<li>-<strong>vtp</strong>: a more recently developed XML version of the vtk format,</li>
<li>-<strong>vtp_ascii</strong>: ASCII version of the vtp format</li>
</ul>
<p><br />
<br />
The specifications for these formats can be found in this <a href="file-formats.html" title="VTK formats PDF">PDF</a> file. See also <a href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a> and <a href="http://mathema.tician.de/node/430" title="there">there</a> for additional information.
<br />
<br />
<br />
<br />
<br /></p></div>
   

  

 <h2 class="category-title">
 <a href="indexe2a5.html?category/Network-I-O">Network data</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index9cca.html?post/networks">Network files</a>
   </h2>
      <div class="post-content"><p>This file type is designed to store any kind of unstructured network (such as delaunay tesselations or more generally cell complexes). In DisPerSE, its usage is restricted to networks of simplices though, and it is mainly used to store ascending and descending manifolds (voids and walls for instance) and persistence pairs as output by <a href="index4656.html?post/mse">mse</a> or Delaunay tessellations as output by <a href="index490e.html?post/Usage">delaunay_nD</a> (<a href="index661f.html?post/skeleton-formats">skeleton files</a> can also be converted to networks using <em><a href="index6160.html?post/skelconv">skelconv</a> -to NDnet</em>). Within network files, networks are represented by setz of vertices and cells of any dimension. A n-cell is a cell of dimension <em>n</em>, which is therefore described, in the case of a simplicial network, as a set of <em>n+1</em> vertices index. In the case of a simplicial <em>complex</em>, only the highest dimensional cell have to be explicitly given, but other type of cells may also be specified. Indeed, extended manifolds for instance are not described as complexes: an ascending 0-manifold in 3D is a set of tetrahedrons (3-cells), triangles (representing ascending 1-manifolds on its boundary), segments (ascending 2-manifolds on its boundary) and vertices (ascending 3-manifolds / critical points). Note that additional information can also be associated to each type of cell (see below).
<br />
The base network format is <a href="indexceff.html?post/NDnet-format">NDnet</a> which is used internally, but this format may be converted to several other more or less complex formats of network files adapted to different applications (see option <em>-to</em> in program <a href="index25e8.html?post/netconv">netconv</a>, a list of available formats is displayed when running the program without argument).<br />
<br />
<br />
<strong><ins>Available formats</ins></strong>:
<br />
<br /></p>
<ul>
<li>-<strong><a href="indexceff.html?post/NDnet-format">NDnet</a></strong> (Read / Write):<br /> This is the format of the network files created or red by <a href="index4656.html?post/mse">mse</a>. It is a relatively complex binary format (it is actually more complex than needed as it is designed to store generic non-simplicial networks) that contains all the information on the geometry and topology of unstructured networks as well as additional data associated to each type of cells.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexd2e2.html?post/NDnet_ascii-format">NDnet_ascii</a></strong> (Read / Write):<br /> This ASCII format contains the same amount of information as <em>NDnet</em> files, but restricted to simplicial networks. It is easy to read and write so it may be used to write reasonably sized networks used as input for <em><a href="index4656.html?post/mse">mse</a></em>.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexda8a.html?post/ply-format">PLY</a></strong> and <strong><a href="indexda8a.html?post/ply-format">PLY_ascii</a></strong> (Read binary only / Write):<br /> This is a rather popular and simple binary or ASCII format that can be used as an interface with other software.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexe8f9.html?post/vtk-network-format">vtk</a></strong>, <strong><a href="indexe8f9.html?post/vtk-network-format">vtk_ascii</a></strong>, <strong><a href="indexe8f9.html?post/vtk-network-format">vtu</a></strong> and <strong><a href="index3bdb.html?post/vtk-network-formats">vtu_ascii</a></strong> (Write only):<br /> These formats are binary and ASCII legacy and XML <a href="http://www.vtk.org/">VTK</a> formats that are readable by several 3D visualization tools, such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a> for instance.</li>
</ul>
<p><br />
<br />
<strong><ins>Additional data</ins></strong>: In addition to the topology and geometry of the network, arbitrary additional information may be associated to each type of cell. Run <em><a href="index25e8.html?post/netconv">netconv</a> filename -info</em> for a list of additional data available in the network file <em>filename</em>. By default, the name of additional data added by <a href="index4656.html?post/mse">mse</a> is relatively explicit, it includes (see also the <em>additional data</em> section of the <a href="index661f.html?post/skeleton-formats">skeleton file format</a> description):
<br />
<br /></p>
<ul>
<li>-<strong>field_value</strong> / <strong>log_field_value</strong> :<br /> The value of the field and its logarithm. The tag <em>field_value</em> corresponds to the input function for <em><a href="index4656.html?post/mse">mse</a></em>, whose Morse-Smale complex is to be computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>cell</strong>:<br /> The <em>type</em> and <em>index</em> of a cell in the original network (prefix may be added). The value is a double precision floating number whose integer part is the index of the cell and decimal part its type. For instance, the 156th vertex (i.e. 0-cell) in the cell complex is represented as 156.0, while the 123th tetrahedron is 123.3. Note that the index of the 0-cell correpond to the index of the pixel / vertices in the original network from which the skeleton was computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>type</strong>:<br /> This usually corresponds to the critical index of a critical point (for instance, vertices of persistence pairs networks), or the type of a persistence pair (i.e. the minimum critical index of the CP in the pair, for segments of persistence pairs networks).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>index</strong><br /> Usually the index of a vertex (e.g. for persistence pairs, additional segment data tagged <em>up_index</em> and <em>down_index</em> correspond to the indices of the vertices with lowest and highest critical index in the persistence pair respectively).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>persistence</strong> / <strong>persistence_ratio</strong> / <strong>persistence_nsigmas</strong> :<br /> The persistence (expressed as a difference, ratio or in <em>number of sigmas</em>) of the persistence pair containing the corresponding critical point. A negative or null value indicates that <em>persistence</em> is not relevant to this particular cell.</li>
</ul>
<p><br /><a name="parent"></a></p>
<ul>
<li>-<strong>parent_index</strong> / <strong>parent_log_index</strong> (vertices only):<br /> For persistence pairs type networks, for each vertex representing an extremum  (i.e. minima and maxima), the index of the vertex that corresponds to the other extremum into which it would be merged if its persistence pair was canceled (indices start at 0). This can be used to reconstruct the tree of the hierarchy of maxima and minima. The value is -1 for non extrema critical points. The difference between the two versions is that the second (<em>parent_log_index</em>) is the hierarchy computed from the logarithm of the field. The second version is useful only for discrete point samples whose MS-complex is obtained from the delaunay tessellation computed with <em><a href="index490e.html?post/Usage">delaunay_nD</a></em>.  Practically, <em>parent_log_index</em> can be used whenever persistence pairs are cancelled in order of increasing ratio (option <em><a href="index4656.html?post/mse#nsig">-nsig</a></em> in <em>mse</em>), and <em>parent_index</em> whenever persistence pairs are cancelled in order of increasing difference  (option <em><a href="index4656.html?post/mse#cut">-cut</a></em> in <em>mse</em>).</li>
</ul>
<p><br /><a name="source"></a></p>
<ul>
<li>-<strong>source_cell</strong> / <strong>source_index</strong>:<br /> For networks representing manifolds (voids, walls, ... obtained with option <a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a> of mse), this represents for each simplex the critical point from which the manifold it belongs to originates (for instance, the minimum corresponding to a void, or the saddle point corresponding to a filament). In <em>source_cell</em>, the critical points is represented by its cell in the initial cell complex (see <strong>cell</strong> above), while <em>source_index</em> gives the index of the critical point in the <a href="index661f.html?post/skeleton-formats">skeleton</a> file or persistence pair network obtained with <a href="index4656.html?post/mse">mse</a> (options <em><a href="index4656.html?post/mse#dumparcs">-dumpArcs</a></em> and <em><a href="index4656.html?post/mse#ppairs">-ppairs</a></em>). See also <a href="index2d20.html?post/Example-1#voids">here</a> and <a href="indexf6f1.html?post/Example-2#walls">there</a> in the tutorial section.</li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexceff.html?post/NDnet-format">NDnet format</a>
   </h2>
      <div class="post-content"><p>This is the native binary format of DisPerSE. Functions for reading and writing <em>NDnet</em> format  in <em>C</em> can be found within the file <code>${DISPERSE_SRC}/src/C/NDnetwork.c</code> (see functions <em>Load_NDnetwork</em> and <em>Save_NDnetwork</em>). The format may seem relatively complex, but most of it is actually optional and not used in disperse (only simplicial complexes are used in DisPerSE). To create DisPerSE input files, it is only necessary to define the highest dimensional n-simplices as a list of (n+1) vertices (see also function <em>CreateNetwork</em>).
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="index4656.html?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).
<br />
<ins>Warning</ins>: in the following, for legacy reasons, the terms <em>n-face</em> and <em>n-cell</em> are used indifferently to designate polygons of dimension <em>n</em> (which are always simplexes in DisPerSE).
<br />
<br />
When using the C functions from Disperse, data is loaded into the following <em>C</em> structure which is close to the actual structure of the file (see file <code>${DISPERSE_SRC}/src/C/NDnetwork.h</code>):</p>

<pre>typedef struct
 {
   int type; // the cell-type
   char name[255];  // name of the field
   double *data;  // value for each of the nfaces[n] n-cells
} NDnetwork_Data;</pre>


<pre>// NDnetwork_SupData is not used in disperse ...
typedef struct
{
   int type; 
   char name[255];
   int datasize;
   char datatype[255];// a string to identity how data should be casted
   void *data;
} NDnetwork_SupData;</pre>


<pre>typedef struct 
{
   char comment[80];
   int periodicity;
   int ndims; // the number of spatial dimensions
   int ndims_net; // number of dimension of the network itself (e.g. 2 for a sphere embedded in 3D)
   int isSimpComplex;  // 1 if network is a simplicial complex (always true in disperse)
   double *x0;  // origin of the bounding box
   double *delta;  // size of the bounding box
   int indexSize; // size of NDNET_UINT type in Bytes
   int cumIndexSize; // size of NDNET_IDCUMT type in Bytes
   char dummy[160-4*2]; // dummy data reserved for future extensions
 
   NDNET_UINT nvertex;  // total number of vertices
   float *v_coord; //vertices coodinates (X_0,Y_0,Z_0,X_1,Y_1,...,Z_nvertex-1)
   
   NDNET_UINT *nfaces; // number of cells of a given type t is given by nfaces[t]
 
   int *haveVertexFromFace; // haveVertexFromFace[n] is 1 if we have an explicit definition of the n-cells (at least one type of cell must be defined).
   NDNET_IDCUMT **f_numVertexIndexCum;// cumulative number of vertice in the t-cells, NULL when cells are simplexes (isSimpComplex=1)
   NDNET_UINT **f_vertexIndex; // list of vertices defining the n-cells is stored in f_vertexIndex[n], all vertices being enumerated for each cell (the indices of the vertices in the kth n-cell start at f_vertexIndex[n][(n+1)*k] )
   // see also macro  NUM_VERTEX_IN_FACE(net,type,face) and VERTEX_IN_FACE(net,type,face)
 
   //This may be computed internally within DisPerSE but does not need to be defined explicitely
   int *haveFaceFromVertex; // haveFaceFromVertex[n] is 1 if we have an explicit list of all the n-cells that contain each vertex (used to navigate within the network)
   NDNET_IDCUMT **v_numFaceIndexCum; // cumulative number of t-cells a vertex v belongs to
   NDNET_UINT **v_faceIndex; // indices of the t-cells in the co-boundary of v ( the list of n-cells of vertex k starts at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k]] and ends at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k+1]] )
   // see also macro  NUM_FACE_IN_VERTEX(net,type,vertex) and  FACE_IN_VERTEX(net,type,vertex)
   
   // This can become extremely memory heavy ... NOT used in DisPerSE
   int **haveFaceFromFace; // haveFaceFromFace[k][n] is 1 if we have an explicit list of all the n-cells that have a boundary/co-boundary relation with each k-cell (used to navigate within the network)
   NDNET_IDCUMT ***f_numFaceIndexCum; //  cumulative number of n-cells having a boundary / co-boundary relation with each k-cell: f_numFaceIndexCum[k][n]
   NDNET_UINT ***f_faceIndex; // indices of the cells (similar to v_faceIndex)
   // see also macro NUM_FACE_IN_FACE(net,ref_type,ref_face,type) and FACE_IN_FACE(net,ref_type,ref_face,type)
   
   int haveVFlags;  // do we have flags associated to each vertex ?
   int *haveFFlags;  // do we have flags associated to each n-cell ?
   unsigned char *v_flag; // nvertex flag values (1 for each vertex) or NULL 
   unsigned char **f_flag; // nfaces[n] flag values (1 of each n-cell) or NULL

   int ndata; // number of additional data fields.
   NDnetwork_Data *data; // array of all additionnal data (data in total)
   
   int nsupData;
   NDnetwork_SupData *supData;

} NDnetwork;</pre>

<p><br />
<br />
The <em>NDnet</em> binary format is organized as follows (blocks are delimited by <em>dummy</em> variables indicating the size of the blocks for FORTRAN compatibility, but they are ignored in C):
<br />
<br /></p>
<table style="margin: 1em auto 1em auto"><caption>NDnet binary format</caption><tr  valign="top"><td width="10%">field</td><td width="10%">type</td><td width="10%">size</td><td width="65%">comment</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> for FORTRAN compatibility</td></tr>
<tr  valign="top"><td>tag</td><td>char(1B)</td><td>16</td><td>identifies the file type. Value : "NDNETWORK"</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndims</td><td>int(4B)</td><td>1</td><td>number of dimensions of the embedding space</td></tr>
<tr  valign="top"><td>ndims_net</td><td>int(4B)</td><td>1</td><td>ndims spanned by the network (=ndims by default)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>comment</td><td>char(1B)</td><td>80</td><td>a comment on the file (string)</td></tr>
<tr  valign="top"><td> periodicity</td><td>int(4B)</td><td>1</td><td> 0=non periodic, if p^th bit is set, boundary are periodic along dimension p</td></tr>
<tr  valign="top"><td>isSimpComplex</td><td>int(4B)</td><td>1</td><td> 1 if network is made of simplices (must be 1 for DisPerSE)</td></tr>
<tr  valign="top"><td>x0</td><td>double(8B)</td><td>ndims</td><td>origin of bounding box</td></tr>
<tr  valign="top"><td>delta</td><td>double(8B)</td><td>ndims</td><td>size of bounding box</td></tr>
<tr  valign="top"><td>index_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_UINT integer format in Bytes</td></tr>
<tr  valign="top"><td>cumindex_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_IDCUMT integer format in Bytes</td></tr>
<tr  valign="top"><td>dummy_ext</td><td>char(1B)</td><td>152</td><td>dummy data reserved for future extensions</td></tr>
<tr  valign="top"><td>nvertex</td><td>NDNET_UINT</td><td>1</td><td>number of vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>v_coords</td><td>float(4B)</td><td>ndims&timesnvertex</td><td>coordinates of the vertices [X0,Y0, ...]</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>nfaces</td><td>NDNET_UINT</td><td>ndims+1</td><td>number of cells of each type (N0,N1,...)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVertexFromFace</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 3 lines are repeated for each (ndims+1) possible cells type , only if haveVertexFromFace[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_vertexIndex[n]</td><td>NDNET_UINT</td><td>(n+1)&timesnfaces[n]</td><td style="background:lightblue">list of (n+1) vertex indices for each n-cell</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromVertex</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells in the co-boundary of each vertex explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 6 lines are repeated for each (ndims+1) possible cells type, only if haveFaceFromVertex[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>numFaceIndexCum[n]</td><td>NDNET_IDCUMT</td><td>nvertex+1</td><td style="background:lightblue">cumulative count of n-cells on vertices co-boundary</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_faceIndex[n]</td><td>NDNET_UINT</td><td>numFaceIndexCum[n]</td><td style="background:lightblue">list of n-cells on the co-boundary of each vertex (vertex i have numFaceIndexCum[n][i+1]-numFaceIndexCum[n][i] of them)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromFace</td><td>int(4B)</td><td>(ndims+1)^2</td><td>are n-cells in the co-boundary of each k-cell explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> This section describes boundary relation between n-cells and k-cells. It is usually empty in DisPerSE (see NDnetwork.c for details) so SKIP IT :)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVFlags</td><td>int(4B)</td><td>1</td><td> 1 if vertex flags are defined</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are skipped if haveVFlags=0</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_flag</td><td>uchar(1B)</td><td>nvertex</td><td style="background:lightblue"> value of the flags for vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFFlags</td><td>int(4B)</td><td>ndims+1</td><td> 1 if flags are defined for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are repeated for each n-cell such that haveFFlags[n]=1</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_flag[n]</td><td>uchar(1B)</td><td>nfaces[n]</td><td style="background:lightblue"> value of the flags for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndata</td><td>int(4B)</td><td>1</td><td> total number of additional fields</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 7 lines are repeated for each additional field (&timesndata)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>type</td><td>int(4B)</td><td>1</td><td style="background:lightblue"> the type of cells (0=vertex, n = n-simplex)</td></tr>
<tr  valign="top"><td>name</td><td>char(1B)</td><td>255</td><td style="background:lightblue"> name of the supplementary data</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>data</td><td>double(8B)</td><td>N</td><td style="background:lightblue"> data associated to cells or vertices. N is nfaces[n] or nvertex depending on the type value.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexd2e2.html?post/NDnet_ascii-format">NDnet_ascii format</a>
   </h2>
      <div class="post-content"><p>This ASCII format is a simpler version of the <a href="indexceff.html?post/NDnet-format">NDnet</a> format, designed to be fully compatible but restricted to simplicial networks. It is easy to read and write and should probably be used for reasonably sized data sets.
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="index4656.html?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).</p>


<p><br />
<br /></p>
<table border="1"><caption> NDnet_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> ANDNET</th><td> header</td></tr>
<tr  valign="top"><th> ndims</th><td> the number of dimensions</td></tr>
<tr  valign="top"><th> #comments go here</th><td> OPTIONAL: should start with '#' if present (the 80 first characters are read and stored).</td></tr>
<tr  valign="top"><th> BBOX [x0_1 .. x0_d] [delta_1 .. delta_d]</th><td> OPTIONAL: the bounding box, defined by the 'ndims' coordinates of the origin 'x0' and extent 'delta'.</td></tr>
<tr  valign="top"><th> nv</th><td> number of vertices</td></tr>
<tr  valign="top"><th> vx[0] vy[0] ...</th><td> the ndims coordinates of the first vertex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each vertex</td></tr>
<tr  valign="top"><td style="background:red" colspan="2" >Simplices definition (0-cells up to ndims-cells). One blue block should be added for each type of explicitly defined simplex. Note that only the highest dimension cells are sufficient to define a complex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> T N</th><td style="background:lightblue"> network has N T-simplices (each T-simplex has (T+1) vertices).</td></tr>
<tr  valign="top"><th style="background:lightblue"> i[0] j[0] ...</th><td style="background:lightblue"> the T+1 indices (start at 0) of the vertices of the first T-simplex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> ...</th><td style="background:lightblue"> one line for each of the N T-simplices</td></tr>
<tr  valign="top"><th> [ADDITIONAL_DATA]</th><td> OPTIONAL: indicate the beginning of the additional data section</td></tr>
<tr  valign="top"><th> additional_data_name_1</th><td> name of the additional data (e.g. field_value for mse input files)</td></tr>
<tr  valign="top"><th> T</th><td> type of simplex it is associated to (T-simplex, 0 means vertices)</td></tr>
<tr  valign="top"><th> val[0]</th><td> value for the first T-simplex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each T-simplex</td></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexda8a.html?post/ply-format">ply format</a>
   </h2>
      <div class="post-content"><p>The PLY format is a relatively generic file format designed to store three dimensional data from 3D scanners with the possibility of associating properties to the polygons. Information on this format can be found on <a href="http://en.wikipedia.org/wiki/PLY_(file_format)" title="PLY format">wikipedia</a>  (see also the <em>External links</em> section). A very efficient C library for reading and writing PLY files in ASCII or binary format is <a href="http://w3.impa.br/~diego/software/rply/" title="RPly">RPly</a> (DisPerSE uses it for PLY files I/O, see files <em>NDnet_PLY_IO.c</em> and <em>NDnet_PLY_IO.h</em>).
<br />
<br />
A typical header for a PLY file readable by <a href="index25e8.html?post/netconv">netconv</a> or <a href="index4656.html?post/mse">mse</a> is as follows:</p>


<pre>ply
format ascii 1.0
element bbox 1
property list uchar double x0 
property list uchar double delta
element vertex 77595
property float x
property float y
property float z
property double field_value
element face 482867
property list uchar uint vertex_indices
end_header</pre>

<p><br />
<br /></p>
<ul>
<li>-<strong>format</strong> may be ASCII or little / big endian binary</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>bbox</strong> element is used to define a bounding box if available (x0 is its origin and delta its extent)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>coordinates</strong> of the vertices are given as vertex properties labeled <em>x</em>, <em>y</em>, and <em>z</em> or <em>x0</em>, <em>x1</em>, ... (the number of this properties gives the dimension of the embedding space)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>faces</strong> are defined by the property vertex_indices, each element corresponding to a list of vertices. A cell is always supposed to be a simplex, so the number of vertices determine the dimension spanned by the complex (a 2D complex may be embedded in a 3D space).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>additional properties</strong> may be defined for cells and vertices. In particular, a  vertex property labeled <em>field_value</em> would be used as input function in <a href="index4656.html?post/mse">mse</a>.</li>
</ul></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexe8f9.html?post/vtk-network-format">vtk network format</a>
   </h2>
      <div class="post-content"><p>VTK formats are developed for the Visualization Tool Kit library (<a href="indexb3eb.html?post/vtk-formats">VTK</a>) and can be used for 3D visualization with software such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a>. Networks are stored as <em>VTK unstructured network data</em> and can be output in fours different VTK formats:
<br /><br /></p>
<ul>
<li>-<strong>vtk</strong>: the legacy format</li>
<li>-<strong>vtk_ascii</strong>: ASCII version of the vtk format</li>
<li>-<strong>vtu</strong>: a more recently developed XML version of the vtk format,</li>
<li>-<strong>vtu_ascii</strong>: ASCII version of the vtu format</li>
</ul>
<p><br />
<br />
The specifications for these formats can be found in this <a href="file-formats.html" title="VTK formats PDF">PDF</a> file. See also <a href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a> and <a href="http://mathema.tician.de/node/430" title="there">there</a> for additional information.
<br />
<br />
<br />
<br />
<br /></p></div>
   

  

 <h2 class="category-title">
 <a href="indexc777.html?category/Field-I-O">Field data</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="indexa0c1.html?post/field-formats">Field files</a>
   </h2>
      <div class="post-content"><p>This file type is designed to store scalar fields sampled over regular grids (i.e. regular images in 2D, 3D and more) or, by extension, coordinates of tracer particles sampling an underlying density field. The main field format is <em>NDfield</em>, which allows to store any type of data (integer, simple or double precision floating point, ...) over arbitrary sized regular grids or as coordinates of tracer particles.
<br />
<br />
<strong><ins>Available formats</ins></strong>:
<br />
<br /></p>
<ul>
<li>-<strong><a href="index16de.html?post/NDfield-format">NDfield</a></strong> (Read / Write):<br />This is the format used internally in DisPerSE, it is efficient and generic as it can store regular grids or sample particles coordinates indifferently.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexd473.html?post/NDfield_ascii-format">NDfield_ascii</a></strong> (Read / Write):<br />A simple ASCII version of the NDfield format, it is as versatile but data is always considered to be double precision floating point.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="index7327.html?post/FITS-format">FITS</a></strong> (Read only):<br />Used to read 2D or 3D regular grids of arbitrary dimensions in the popular Flexible Image Transport System (<a href="http://en.wikipedia.org/wiki/FITS" title="FITSS format">FITS</a>) image format. Also used for <a href="http://healpix.jpl.nasa.gov/" title="HEALPIX">HEALPIX</a> tessellations of the sphere.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="index744c.html?post/survey_ascii-format">survey_ascii</a></strong>(Read only):<br />A simple ASCII format whose main purpose is to easily read coordinates of discretely sampled astrophysical surveys (e.g. such as an <a href="http://www.sdss.org/" title="SDSS">SDSS</a> galaxy catalog). Try this if you use spherical coordinates or if distance is measured by redshift for instance.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexb2ad.html?post/SDL-image">SDL-image</a></strong> (Read only):<br />This input format is used to read 2D regular grids encoded in a popular picture format readable by <a href="http://www.libsdl.org/projects/SDL_image/docs/SDL_image.html" title="SDL-image">SDL-image</a> library (jpg, png, gif, ...).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexd991.html?post/vtk-field-format">vtk</a></strong>, <strong><a href="indexd991.html?post/vtk-field-format">vtk_ascii</a></strong>, <strong><a href="indexd991.html?post/vtk-field-format">vti</a></strong> and <strong><a href="indexd991.html?post/vtk-field-format">vti_ascii</a></strong> (Write only):<br />These formats are binary and ASCII legacy and XML <a href="http://www.vtk.org/">VTK</a> formats that are readable by several 3D visualization tools, such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a> for instance.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="index9cca.html?post/networks">NDnet</a></strong> (Write only):<br /> Using this format, field files representing tracer particles coordinates can be converted to <a href="index9cca.html?post/networks">unstructured networks</a> (use <em><a href="index25e8.html?post/netconv">netconv</a></em> to convert <em>NDnet</em> files to other network formats). Regular grids conversion is not implemented yet due to the huge size of the output network.</li>
</ul>
<p><br />
<br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index16de.html?post/NDfield-format">NDfield format</a>
   </h2>
      <div class="post-content"><p>This is the native binary format of DisPerSE. Functions for reading and writing <em>NDfield</em> format  in <em>C</em> can be found within the file <code>${DISPERSE_SRC}/src/C/NDfield.c</code> (see functions <em>Load_NDfield</em> and <em>Save_NDfield</em>).
<br />
<br />
When using the C functions from Disperse, data is loaded into the following <em>C</em> structure which is close to the actual structure of the file (see file <code>${DISPERSE_SRC}/src/C/NDfield.h</code>):</p>


<pre>#define ND_CHAR   (1&lt;&lt;0)
#define ND_UCHAR  (1&lt;&lt;1)
#define ND_SHORT  (1&lt;&lt;2)
#define ND_USHORT (1&lt;&lt;3)
#define ND_INT    (1&lt;&lt;4)
#define ND_UINT   (1&lt;&lt;5)
#define ND_LONG   (1&lt;&lt;6)
#define ND_ULONG  (1&lt;&lt;7)
#define ND_FLOAT  (1&lt;&lt;8)
#define ND_DOUBLE (1&lt;&lt;9)</pre>


<pre>typedef struct NDfield_str
{
 char comment[80];  // a comment on the data
 int dims[NDFIELD_MAX_DIMS];  // dimensions of the grid, must be [ndims,nparticles] when data represents sample particles coordinates (i.e. when fdims_index!=0)
 int ndims;  // number of dimensions of the space
 int n_dims;  // number of meaningfull values in dims array
 int fdims_index; // if 0, the field is a regular grid of dimensions dims, else the file contains the dims[0] coordinates of dims[1] particles.
 int datatype;  // type of the data (one of the ND_... defined above)
 double x0[NDFIELD_MAX_DIMS];  // origin of the bounding box
 double delta[NDFIELD_MAX_DIMS];  // extent of the bounding box
 char dummy[160];  // dummy data, for future extensions or for storing anything you want.

 void *val;  // pointer to data

 long nval;  // total number of particles (fdims_index==1) or pixels (fdims_index==0)
 int datasize;  // size in bytes of datatype type.
} NDfield;</pre>


<p><br />
<br />
The <em>NDfield</em> binary format is organized as follows (blocks are delimited by <em>dummy</em> variables indicating the size of the blocks for FORTRAN compatibility, but they are ignored in C):
<br />
<br /></p>
<table style="margin: 1em auto 1em auto"><caption>NDnet binary format</caption><tr ><td width="10%" >field</td><td width="10%" >type</td><td width="10%">size</td><td width="65%" >comment</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> for FORTRAN compatibility</td></tr>
<tr  valign="top"><td>tag</td><td>char(1B)</td><td>16</td><td>identifies the file type. Value : "NDFIELD"</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndims</td><td>int(4B)</td><td>1</td><td>number of dimensions of the embedding space</td></tr>
<tr  valign="top"><td>dims</td><td>int(4B)</td><td>20</td><td>size of the grid in pixels along each dimension, or [ndims,nparticles] if data represents particle coordinates (i.e. fdims_index=1)</td></tr>
<tr  valign="top"><td>fdims_index</td><td>int(4B)</td><td>1</td><td> 0 if data represents a regular grid, 1 if it represents coordinates of tracer particles</td></tr>
<tr  valign="top"><td>datatype</td><td>int(4B)</td><td>1</td><td>type of data stored (see below)</td></tr>
<tr  valign="top"><td>x0</td><td>double(8B)</td><td>20</td><td>origin of bounding box (first ndims val. are meaningfull)</td></tr>
<tr  valign="top"><td>delta</td><td>double(8B)</td><td>20</td><td>size of bounding box (first ndims val. are meaningfull)</td></tr>
<tr  valign="top"><td>dummy_ext</td><td>char(1B)</td><td>160</td><td>dummy data reserved for future extensions</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>data</td><td>size of datatype</td><td>N</td><td>data itself (N may be the number of pixels or ndism times the number of particles)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
</table>

<p><br />
<br /></p>
<table border="1"><caption> Possible data types</caption><tr align="center"><td width="20%" style="background:grey">name</td><td width="20%" style="background:grey">size (Bytes)</td><td width="20%" style="background:grey">type</td><td width="20%" style="background:grey">value</td></tr>
<tr align="center"><td style="background:grey"> ND_CHAR </td><td> 1 </td><td> integer </td><td>  1 (=1<<0)</td></tr>
<tr  align="center"><td style="background:grey"> ND_UCHAR </td><td> 1 </td><td> integer </td><td>  2 (=1<<1)</td></tr>
<tr align="center"><td style="background:grey"> ND_SHORT </td><td> 2 </td><td> integer </td><td>  4 (=1<<2)</td></tr>
<tr  align="center"><td style="background:grey"> ND_USHORT </td><td> 2 </td><td> integer </td><td>  8 (=1<<3)</td></tr>
<tr  align="center"><td style="background:grey"> ND_INT </td><td> 4 </td><td> integer </td><td>  16 (=1<<4)</td></tr>
<tr  align="center"><td style="background:grey"> ND_UINT  </td><td> 4 </td><td> integer </td><td>  32 (=1<<5)</td></tr>
<tr  align="center"><td style="background:grey"> ND_LONG </td><td> 8 </td><td> integer </td><td>  64 (=1<<6)</td></tr>
<tr  align="center"><td style="background:grey"> ND_ULONG </td><td> 8 </td><td> integer </td><td>  128 (=1<<7)</td></tr>
<tr  align="center"><td style="background:grey"> ND_FLOAT </td><td> 4 </td><td> float </td><td>  256 (=1<<8)</td></tr>
<tr  align="center"><td style="background:grey"> ND_DOUBLE </td><td> 8 </td><td> float </td><td>  512 (=1<<9)</td></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexd473.html?post/NDfield_ascii-format">NDfield_ascii format</a>
   </h2>
      <div class="post-content"><p>A simple ASCII version of the <a href="index16de.html?post/NDfield-format">NDfield</a> format used to represent either uniform grids or particles coordinates. Data type is always interpreted as double precision floating point.
<br />
<br /></p>
<table border="1"><caption> NDfield_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th>ANDFIELD	COORDS</th><td>header (COORDS keyword is optional, if present, values are interpreted as coordinates, or else, as pixel values)</td></tr>
<tr  valign="top"><th>[N_1 ... N_ndims]</th><td>size of the grid along each of the ndims dimensions (in pixels) or number of dimensions and number of particles if COORDS keyword is in the header (= [ndims,nparticles])</td></tr>
<tr  valign="top"><th>BBOX [X0_1 ... X0_ndims] [delta_1 ... delta_ndims]</th><td>OPTIONAL: bounding box definition 	(origin and extent)</td></tr>
<tr  valign="top"><th>V_1 V_2</th><td> values (any number of values can be on the same line)</td></tr>
<tr  valign="top"><th>V_3</th><td> no particular formating is required</td></tr>
<tr  valign="top"><th>...</th><td> Repeat enough time to define a number of values equal to the number of pixels or the number of particles (if COORDS keyword is in the header)</td></tr>
</table></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index7327.html?post/FITS-format">FITS format</a>
   </h2>
      <div class="post-content"><p>This field format is used to read 2D or 3D regular grids of arbitrary dimensions in the popular Flexible Image Transport System (<a href="http://en.wikipedia.org/wiki/FITS" title="FITSS format">FITS</a>) image format. A popular library for reading and writing FITS image in <em>C</em> or <em>FORTRAN</em> is <a href="http://heasarc.gsfc.nasa.gov/docs/software/fitsio/fitsio.html" title="FITS IO">CFITSIO</a>, which must be installed for DisPerSE to be able to use this kind of files.
<br />
<br />
This file format is also used for storing <a href="http://healpix.jpl.nasa.gov/" title="HEALPIX">HEALPIX</a> tesselations of the sphere. DisPerSE will automatically detect if the FITS file contains a HEALPIX tesselation.
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index744c.html?post/survey_ascii-format">survey_ascii format</a>
   </h2>
      <div class="post-content"><p>This is a simple ASCII format whose main purpose is to easily read coordinates of discretely sampled astrophysical surveys (e.g. such as an <a href="http://www.sdss.org/" title="SDSS">SDSS</a> galaxy catalog). It should be considered when using spherical coordinates systems or if distance is measured by redshift for instance.
<br />
<br />
In this format, particles properties are encoded in an ASCII array where each row corresponds to one particle and each column to one property. Each column must have a name defined in the header (the first line of the file, starting with character <em>#</em>). An survey_ascii file may look like this:
<br />
<br /></p>

<pre># ra dec z my_field
+2.115401e+02	+6.313433e-01	+2.666800e-01  1	
+2.115633e+02	+7.550188e-01	+1.259900e-01  0	
+2.115687e+02	+8.108763e-01	+3.646600e-01  0	
+2.117158e+02	+6.393598e-01	+1.143600e-01  1	
+2.116826e+02	+6.528485e-01	+2.455700e-01  1	
+2.116993e+02	+6.509297e-01	+1.199000e-01  0	
+2.115738e+02	+7.772653e-01	+3.240600e-01  0	
+2.116198e+02	+6.950604e-01	+1.987300e-01  0	
+2.116773e+02	+7.085776e-01	+2.561900e-01  1</pre>

<p><br />
<br />
The name of a column defines its role if it matches one of the following keywords:
<br />
<br /></p>
<table border="1"><caption> header keywords</caption><tr align="center"><td width="20%" style="background:grey">Keyword</td><td width="40%" style="background:grey">Meaning</td></tr>
<tr align="center"><td style="background:grey"> px </td><td> X coordinate of the particle</td></tr>
<tr align="center"><td style="background:grey"> py </td><td> Y coordinate of the particle</td></tr>
<tr align="center"><td style="background:grey"> pz </td><td> Z coordinate of the particle</td></tr>
<tr align="center"><td style="background:grey"> vx </td><td> X component of the velocity</td></tr>
<tr align="center"><td style="background:grey"> vy </td><td> Y component of the velocity</td></tr>
<tr align="center"><td style="background:grey"> vz </td><td> Z component of the velocity</td></tr>
<tr align="center"><td style="background:grey"> id </td><td> an index associated to the particle</td></tr>
<tr align="center"><td style="background:grey"> ra </td><td> The <a href="http://en.wikipedia.org/wiki/Right_ascension">right ascension</a> of the particle</td></tr>
<tr align="center"><td style="background:grey"> dec </td><td> The <a href="http://en.wikipedia.org/wiki/Declination">declination</a> of the particle</td></tr>
<tr align="center"><td style="background:grey"> z </td><td> The <a href="http://en.wikipedia.org/wiki/Redshift">redshift</a> of the particle.</td></tr>
</table>

<p><br />
<br />
When particles coordinates are defined with <em>ra</em>, <em>dec</em> or <em>z</em> (redshift), DisPerSE automatically transform them into cartesian coordinates using the standard LCDM model to compute distances (Omega_m=0.27, Omega_L=0.73 ). This transformation can be inverted on the output skeletons and networks using options <em>-toRaDecZ</em> and <em>-toRaDecDist</em> of <a href="index6160.html?post/skelconv">skelconv</a> and <a href="index25e8.html?post/netconv">netconv</a>.</p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexb2ad.html?post/SDL-image">SDL-image format</a>
   </h2>
      <div class="post-content"><p>This input format is used to read 2D regular grids encoded in a popular picture format readable by <a href="http://www.libsdl.org/projects/SDL_image/docs/SDL_image.html" title="SDL-image">SDL-image</a> library (jpg, png, gif, ...). When using this format as input to <a href="index4656.html?post/mse">mse</a>, the field whose topology is computed is the luminosity L of the image, a weighted average of the RED, GREEN and BLUE components of the image:
<br />
<br /></p>

<pre>L = 0.2989*RED + 0.5870*GREEN + 0.1140*BLUE</pre>

<p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br /></p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="indexd991.html?post/vtk-field-format">vtk field format</a>
   </h2>
      <div class="post-content"><p>VTK formats are developed for the Visualization Tool Kit library (<a href="indexb3eb.html?post/vtk-formats">VTK</a>) and can be used for 3D visualization with software such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a>. Only regular grids field types can be converted to VTK (for particle type fields, convert to <em>NDnet</em> <a href="index9cca.html?post/networks">unstructured network</a> format first and then use <em><a href="index25e8.html?post/netconv">netconv</a> -to vtk</em>). Regular grids are stored as <em>VTK image data</em> and can be output in fours different VTK formats:
<br /><br /></p>
<ul>
<li>-<strong>vtk</strong>: the legacy format</li>
<li>-<strong>vtk_ascii</strong>: ASCII version of the vtk format</li>
<li>-<strong>vti</strong>: a more recently developed XML version of the vtk format,</li>
<li>-<strong>vti_ascii</strong>: ASCII version of the vtu format</li>
</ul>
<p><br />
<br />
The specifications for these formats can be found in this <a href="file-formats.html" title="VTK formats PDF">PDF</a> file. See also <a href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a> and <a href="http://mathema.tician.de/node/430" title="there">there</a> for additional information.
<br />
<br />
<br />
<br /></p></div>
   

  

 <h2 class="category-title">
 <a href="indexdc31.html?category/References">Contact &amp; References</a>
 </h2>

  
   <h2 class="post-title">
     &#187;
     <a href="index5399.html?post/Contact">Contact</a>
   </h2>
      <div class="post-content"><p>For any question regarding DisPerSE or this website, please contact <strong style="color:blue"> sousbie<em>(AT)</em>iap<em>.</em>fr</strong>.</p></div>
   
   <h2 class="post-title">
     &#187;
     <a href="index3876.html?post/References">References</a>
   </h2>
      <div class="post-content"><p>A few references:
<br />
<br />
<ins>DisPerSE:</ins> (see therein for references on discrete Morse theory and persistence)
<br />
<br /></p>
<ul>
<li>-Sousbie, T.,  "The persistent cosmic web and its filamentary structure - I. Theory and implementation", 2011,  Monthly Notices of the Royal Astronomical Society,  414,  350</li>
</ul>
<p><br /></p>
<ul>
<li>-Sousbie, T., Pichon, C., Kawahara, H.,  "The persistent cosmic web and its filamentary structure - II. Illustrations", 2011,  Monthly Notices of the Royal Astronomical Society,  414,  384</li>
</ul>
<p><br />
<br />
<ins>Books on persistence and discrete Morse-theory:</ins>
<br />
<br /></p>
<ul>
<li>-Zomorodian A. J., "Topology for computing", 2009, Vol. 16 of Cambridge Monographs on Applied and Computational Mathematics, Cambridge University Press, Cambridge 2, 19, 32</li>
</ul>
<p><br /></p>
<ul>
<li>-Edelsbrunner, H. &amp; Harer, J.L., "Computational Topology", 2010</li>
</ul>
<p><br /></p>
<ul>
<li>-Gyulassy A., 2009, PhD thesis, Univ. California Berkeley 2, 8, 13</li>
</ul>
<p><br /></p>
<ul>
<li>-Forman, R., "A user’s guide to discrete morse theory", 2002</li>
</ul>
<p><br />
<br /></p>


<p>There is also a swarm of scientific articles dealing with these topics that you can find on the net, just google it :)</p></div>
   

 
</div>



  </div>
</div> <!-- End #main -->

<div id="sidebar">
  <div id="blognav">
    <div class="categories"><ul><li><a href="index1694.html?category/Download">Download</a></li><li><a href="indexba87.html?category/Install">Install</a></li><li><a href="index3c4a.html?category/Overview">Overview</a></li><li><a href="index4559.html?category/Terminology">Terminology</a></li><li><a href="index4f3e.html?category/Manual">Manual</a></li><li><a href="index55a0.html?category/Quick-start">Tutorial</a></li><li><a href="index3333.html?category/Skeleton-I-O">Skeleton data</a></li><li><a href="indexe2a5.html?category/Network-I-O">Network data</a></li><li><a href="indexc777.html?category/Field-I-O">Field data</a></li><li><a href="indexdc31.html?category/References">Contact &amp; References</a></li></ul></div>  </div> <!-- End #blognav -->
  
  <div id="blogextra">
      </div> <!-- End #blogextra -->
</div>

</div> <!-- End #wrapper -->

<div id="footer">
  <p>Powered by <a href="http://www.dotclear.net/">DotClear</a> - Contact: sousbie<em>(AT)</em>iap<em>.</em>fr . </p>
</div>
</div> <!-- End #page -->
</body>

<!-- Mirrored from localhost/dotclear/index.php?archive by HTTrack Website Copier/3.x [XR&CO'2010], Sun, 27 Jan 2013 10:35:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
