<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from localhost/dotclear/index.php?category/Network-I-O by HTTrack Website Copier/3.x [XR&CO'2010], Sun, 27 Jan 2013 10:35:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="ROBOTS" content="NOINDEX, FOLLOW" />
  
  <title>Network data - DisPerSE - persistent structures identification</title>

  <meta name="description" lang="en" content="" />
  <meta name="copyright" content="sousbie" />
  <meta name="author" content="thierry sousbie" />
  <meta name="date" scheme="W3CDTF" content="2013-01-27T10:34:14+01:00" />
  
  <link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />
  <meta name="dc.title" lang="en" content="Network data - DisPerSE - persistent structures identification" />
  <meta name="dc.description" lang="en" content="" />
  <meta name="dc.language" content="en" />
  <meta name="dc.publisher" content="thierry sousbie" />
  <meta name="dc.rights" content="sousbie" />
  <meta name="dc.date" scheme="W3CDTF" content="2013-01-27T10:34:14+01:00" />
  <meta name="dc.type" content="text" />
  <meta name="dc.format" content="text/html" />
  <!--
  <link rel="top" href="http://localhost/dotclear/index.php?" title="Home" />
  <link rel="contents" href="http://localhost/dotclear/index.php?archive" title="Archives" />
   -->
                    
    <link rel="chapter" href="indexe8f9.html?post/vtk-network-format" title="vtk network format" />
          
    <link rel="chapter" href="indexda8a.html?post/ply-format" title="ply format" />
          
    <link rel="chapter" href="indexd2e2.html?post/NDnet_ascii-format" title="NDnet_ascii format" />
          
    <link rel="chapter" href="indexceff.html?post/NDnet-format" title="NDnet format" />
          
    <link rel="chapter" href="index9cca.html?post/networks" title="Network files" />
    
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="../images/indexe8ac.php?feed/category/Network-I-O/atom" />
  
  <link rel="shortcut icon" href="../images/favicon.ico" />

<style type="text/css" media="screen">
@import url(../images/style.css);
</style>
<style type="text/css" media="print">
@import url(../images/print.css);
</style>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37686840-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body class="dc-category">
<div id="page">
<div id="top">
<!--
<h1><span><a href="http://localhost/dotclear/index.php?">DisPerSE - persistent structures identification</a></span></h1>
 -->

  </div>

<p id="prelude">
<a href="indexd41d.html?">Home</a> |
<a href="index888d.html?archive">Show all</a>
</p>

<!--
<ul id="nav-box">
2.
<li><a href="http://localhost/dotclear/index.php?">Accueil</a></li>
3.
<li><a href="http://localhost/dotclear/index.php?archive" title="Liste des mois de publication">Archives</a></li>
4.
<li><a href="http://localhost/dotclear/index.php?contact" title="Formulaire de contact">Me contacter</a></li>
5.
</ul>
 -->

<div id="wrapper">

<div id="main">
  <div id="content">

  <div id="content-info">
    <h1 class="title">    Network data</h1>
    <p><br _moz_editor_blogus_node="TRUE" _moz_dirty="" /></p>    <!--
          <p><a type="application/atom+xml" href="http://localhost/dotclear/index.php?feed/category/Network-I-O/atom"
      title="This category's entries Atom feed" class="feed">Entries feed</a>
	
            </p>
        -->
  </div>
   
    <!--
  <div class="context-nav">
    Network data</br>
    <ul>
          <li><a href="http://localhost/dotclear/index.php?post/networks">&#187; Network files</a></li>
          <li><a href="http://localhost/dotclear/index.php?post/NDnet-format">&#187; NDnet format</a></li>
          <li><a href="http://localhost/dotclear/index.php?post/NDnet_ascii-format">&#187; NDnet_ascii format</a></li>
          <li><a href="http://localhost/dotclear/index.php?post/ply-format">&#187; ply format</a></li>
          <li><a href="http://localhost/dotclear/index.php?post/vtk-network-format">&#187; vtk network format</a></li>
        </ul>
  </div>
-->

  
    <div id="p15" class="post odd first" lang="en" xml:lang="en">

<!-- 
    <p class="day-date">Friday, May  9 2425</p>  -->  
<!-- 
    <b1>&rsaquo;<a href="http://localhost/dotclear/index.php?post/networks">Network files</a></b1>
 -->  

    <h2 class="post-title"></br>&rsaquo;<a
    href="index9cca.html?post/networks">Network files</a></h2>

    <!-- 
    <p class="post-info">By thierry sousbie    on Friday, May  9 2425, 06:54</p>
     -->  
    
    
    <!--
        -->

    <!--
          <div class="post-content"><p>This file type is designed to store any kind of unstructured network (such as delaunay tesselations or more generally cell complexes). In DisPerSE, its usage is restricted to networks of simplices though, and it is mainly used to store ascending and descending manifolds (voids and walls for instance) and persistence pairs as output by <a href="/dotclear/index.php?post/mse">mse</a> or Delaunay tessellations as output by <a href="/dotclear/index.php?post/Usage">delaunay_nD</a> (<a href="/dotclear/index.php?post/skeleton-formats">skeleton files</a> can also be converted to networks using <em><a href="/dotclear/index.php?post/skelconv">skelconv</a> -to NDnet</em>). Within network files, networks are represented by setz of vertices and cells of any dimension. A n-cell is a cell of dimension <em>n</em>, which is therefore described, in the case of a simplicial network, as a set of <em>n+1</em> vertices index. In the case of a simplicial <em>complex</em>, only the highest dimensional cell have to be explicitly given, but other type of cells may also be specified. Indeed, extended manifolds for instance are not described as complexes: an ascending 0-manifold in 3D is a set of tetrahedrons (3-cells), triangles (representing ascending 1-manifolds on its boundary), segments (ascending 2-manifolds on its boundary) and vertices (ascending 3-manifolds / critical points). Note that additional information can also be associated to each type of cell (see below).
<br />
The base network format is <a href="/dotclear/index.php?post/NDnet-format">NDnet</a> which is used internally, but this format may be converted to several other more or less complex formats of network files adapted to different applications (see option <em>-to</em> in program <a href="/dotclear/index.php?post/netconv">netconv</a>, a list of available formats is displayed when running the program without argument).<br />
<br />
<br />
<strong><ins>Available formats</ins></strong>:
<br />
<br /></p>
<ul>
<li>-<strong><a href="/dotclear/index.php?post/NDnet-format">NDnet</a></strong> (Read / Write):<br /> This is the format of the network files created or red by <a href="/dotclear/index.php?post/mse">mse</a>. It is a relatively complex binary format (it is actually more complex than needed as it is designed to store generic non-simplicial networks) that contains all the information on the geometry and topology of unstructured networks as well as additional data associated to each type of cells.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="/dotclear/index.php?post/NDnet_ascii-format">NDnet_ascii</a></strong> (Read / Write):<br /> This ASCII format contains the same amount of information as <em>NDnet</em> files, but restricted to simplicial networks. It is easy to read and write so it may be used to write reasonably sized networks used as input for <em><a href="/dotclear/index.php?post/mse">mse</a></em>.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="/dotclear/index.php?post/ply-format">PLY</a></strong> and <strong><a href="/dotclear/index.php?post/ply-format">PLY_ascii</a></strong> (Read binary only / Write):<br /> This is a rather popular and simple binary or ASCII format that can be used as an interface with other software.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="/dotclear/index.php?post/vtk-network-format">vtk</a></strong>, <strong><a href="/dotclear/index.php?post/vtk-network-format">vtk_ascii</a></strong>, <strong><a href="/dotclear/index.php?post/vtk-network-format">vtu</a></strong> and <strong><a href="/dotclear/index.php?post/vtk-network-formats">vtu_ascii</a></strong> (Write only):<br /> These formats are binary and ASCII legacy and XML <a href="http://www.vtk.org/">VTK</a> formats that are readable by several 3D visualization tools, such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a> for instance.</li>
</ul>
<p><br />
<br />
<strong><ins>Additional data</ins></strong>: In addition to the topology and geometry of the network, arbitrary additional information may be associated to each type of cell. Run <em><a href="/dotclear/index.php?post/netconv">netconv</a> filename -info</em> for a list of additional data available in the network file <em>filename</em>. By default, the name of additional data added by <a href="/dotclear/index.php?post/mse">mse</a> is relatively explicit, it includes (see also the <em>additional data</em> section of the <a href="/dotclear/index.php?post/skeleton-formats">skeleton file format</a> description):
<br />
<br /></p>
<ul>
<li>-<strong>field_value</strong> / <strong>log_field_value</strong> :<br /> The value of the field and its logarithm. The tag <em>field_value</em> corresponds to the input function for <em><a href="/dotclear/index.php?post/mse">mse</a></em>, whose Morse-Smale complex is to be computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>cell</strong>:<br /> The <em>type</em> and <em>index</em> of a cell in the original network (prefix may be added). The value is a double precision floating number whose integer part is the index of the cell and decimal part its type. For instance, the 156th vertex (i.e. 0-cell) in the cell complex is represented as 156.0, while the 123th tetrahedron is 123.3. Note that the index of the 0-cell correpond to the index of the pixel / vertices in the original network from which the skeleton was computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>type</strong>:<br /> This usually corresponds to the critical index of a critical point (for instance, vertices of persistence pairs networks), or the type of a persistence pair (i.e. the minimum critical index of the CP in the pair, for segments of persistence pairs networks).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>index</strong><br /> Usually the index of a vertex (e.g. for persistence pairs, additional segment data tagged <em>up_index</em> and <em>down_index</em> correspond to the indices of the vertices with lowest and highest critical index in the persistence pair respectively).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>persistence</strong> / <strong>persistence_ratio</strong> / <strong>persistence_nsigmas</strong> :<br /> The persistence (expressed as a difference, ratio or in <em>number of sigmas</em>) of the persistence pair containing the corresponding critical point. A negative or null value indicates that <em>persistence</em> is not relevant to this particular cell.</li>
</ul>
<p><br /><a name="parent"></a></p>
<ul>
<li>-<strong>parent_index</strong> / <strong>parent_log_index</strong> (vertices only):<br /> For persistence pairs type networks, for each vertex representing an extremum  (i.e. minima and maxima), the index of the vertex that corresponds to the other extremum into which it would be merged if its persistence pair was canceled (indices start at 0). This can be used to reconstruct the tree of the hierarchy of maxima and minima. The value is -1 for non extrema critical points. The difference between the two versions is that the second (<em>parent_log_index</em>) is the hierarchy computed from the logarithm of the field. The second version is useful only for discrete point samples whose MS-complex is obtained from the delaunay tessellation computed with <em><a href="/dotclear/index.php?post/Usage">delaunay_nD</a></em>.  Practically, <em>parent_log_index</em> can be used whenever persistence pairs are cancelled in order of increasing ratio (option <em><a href="/dotclear/index.php?post/mse#nsig">-nsig</a></em> in <em>mse</em>), and <em>parent_index</em> whenever persistence pairs are cancelled in order of increasing difference  (option <em><a href="/dotclear/index.php?post/mse#cut">-cut</a></em> in <em>mse</em>).</li>
</ul>
<p><br /><a name="source"></a></p>
<ul>
<li>-<strong>source_cell</strong> / <strong>source_index</strong>:<br /> For networks representing manifolds (voids, walls, ... obtained with option <a href="/dotclear/index.php?post/mse#dumpmanifolds">-dumpManifolds</a> of mse), this represents for each simplex the critical point from which the manifold it belongs to originates (for instance, the minimum corresponding to a void, or the saddle point corresponding to a filament). In <em>source_cell</em>, the critical points is represented by its cell in the initial cell complex (see <strong>cell</strong> above), while <em>source_index</em> gives the index of the critical point in the <a href="/dotclear/index.php?post/skeleton-formats">skeleton</a> file or persistence pair network obtained with <a href="/dotclear/index.php?post/mse">mse</a> (options <em><a href="/dotclear/index.php?post/mse#dumparcs">-dumpArcs</a></em> and <em><a href="/dotclear/index.php?post/mse#ppairs">-ppairs</a></em>). See also <a href="/dotclear/index.php?post/Example-1#voids">here</a> and <a href="/dotclear/index.php?post/Example-2#walls">there</a> in the tutorial section.</li>
</ul></div>
        -->
    <div class="post-content"><p>This file type is designed to store any kind of unstructured network (such as delaunay tesselations or more generally cell complexes). In DisPerSE, its usage is restricted to networks of simplices though, and it is mainly used to store ascending and descending manifolds (voids and walls for instance) and persistence pairs as output by <a href="index4656.html?post/mse">mse</a> or Delaunay tessellations as output by <a href="index490e.html?post/Usage">delaunay_nD</a> (<a href="index661f.html?post/skeleton-formats">skeleton files</a> can also be converted to networks using <em><a href="index6160.html?post/skelconv">skelconv</a> -to NDnet</em>). Within network files, networks are represented by setz of vertices and cells of any dimension. A n-cell is a cell of dimension <em>n</em>, which is therefore described, in the case of a simplicial network, as a set of <em>n+1</em> vertices index. In the case of a simplicial <em>complex</em>, only the highest dimensional cell have to be explicitly given, but other type of cells may also be specified. Indeed, extended manifolds for instance are not described as complexes: an ascending 0-manifold in 3D is a set of tetrahedrons (3-cells), triangles (representing ascending 1-manifolds on its boundary), segments (ascending 2-manifolds on its boundary) and vertices (ascending 3-manifolds / critical points). Note that additional information can also be associated to each type of cell (see below).
<br />
The base network format is <a href="indexceff.html?post/NDnet-format">NDnet</a> which is used internally, but this format may be converted to several other more or less complex formats of network files adapted to different applications (see option <em>-to</em> in program <a href="index25e8.html?post/netconv">netconv</a>, a list of available formats is displayed when running the program without argument).<br />
<br />
<br />
<strong><ins>Available formats</ins></strong>:
<br />
<br /></p>
<ul>
<li>-<strong><a href="indexceff.html?post/NDnet-format">NDnet</a></strong> (Read / Write):<br /> This is the format of the network files created or red by <a href="index4656.html?post/mse">mse</a>. It is a relatively complex binary format (it is actually more complex than needed as it is designed to store generic non-simplicial networks) that contains all the information on the geometry and topology of unstructured networks as well as additional data associated to each type of cells.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexd2e2.html?post/NDnet_ascii-format">NDnet_ascii</a></strong> (Read / Write):<br /> This ASCII format contains the same amount of information as <em>NDnet</em> files, but restricted to simplicial networks. It is easy to read and write so it may be used to write reasonably sized networks used as input for <em><a href="index4656.html?post/mse">mse</a></em>.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexda8a.html?post/ply-format">PLY</a></strong> and <strong><a href="indexda8a.html?post/ply-format">PLY_ascii</a></strong> (Read binary only / Write):<br /> This is a rather popular and simple binary or ASCII format that can be used as an interface with other software.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong><a href="indexe8f9.html?post/vtk-network-format">vtk</a></strong>, <strong><a href="indexe8f9.html?post/vtk-network-format">vtk_ascii</a></strong>, <strong><a href="indexe8f9.html?post/vtk-network-format">vtu</a></strong> and <strong><a href="index3bdb.html?post/vtk-network-formats">vtu_ascii</a></strong> (Write only):<br /> These formats are binary and ASCII legacy and XML <a href="http://www.vtk.org/">VTK</a> formats that are readable by several 3D visualization tools, such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a> for instance.</li>
</ul>
<p><br />
<br />
<strong><ins>Additional data</ins></strong>: In addition to the topology and geometry of the network, arbitrary additional information may be associated to each type of cell. Run <em><a href="index25e8.html?post/netconv">netconv</a> filename -info</em> for a list of additional data available in the network file <em>filename</em>. By default, the name of additional data added by <a href="index4656.html?post/mse">mse</a> is relatively explicit, it includes (see also the <em>additional data</em> section of the <a href="index661f.html?post/skeleton-formats">skeleton file format</a> description):
<br />
<br /></p>
<ul>
<li>-<strong>field_value</strong> / <strong>log_field_value</strong> :<br /> The value of the field and its logarithm. The tag <em>field_value</em> corresponds to the input function for <em><a href="index4656.html?post/mse">mse</a></em>, whose Morse-Smale complex is to be computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>cell</strong>:<br /> The <em>type</em> and <em>index</em> of a cell in the original network (prefix may be added). The value is a double precision floating number whose integer part is the index of the cell and decimal part its type. For instance, the 156th vertex (i.e. 0-cell) in the cell complex is represented as 156.0, while the 123th tetrahedron is 123.3. Note that the index of the 0-cell correpond to the index of the pixel / vertices in the original network from which the skeleton was computed.</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>type</strong>:<br /> This usually corresponds to the critical index of a critical point (for instance, vertices of persistence pairs networks), or the type of a persistence pair (i.e. the minimum critical index of the CP in the pair, for segments of persistence pairs networks).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>index</strong><br /> Usually the index of a vertex (e.g. for persistence pairs, additional segment data tagged <em>up_index</em> and <em>down_index</em> correspond to the indices of the vertices with lowest and highest critical index in the persistence pair respectively).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>persistence</strong> / <strong>persistence_ratio</strong> / <strong>persistence_nsigmas</strong> :<br /> The persistence (expressed as a difference, ratio or in <em>number of sigmas</em>) of the persistence pair containing the corresponding critical point. A negative or null value indicates that <em>persistence</em> is not relevant to this particular cell.</li>
</ul>
<p><br /><a name="parent"></a></p>
<ul>
<li>-<strong>parent_index</strong> / <strong>parent_log_index</strong> (vertices only):<br /> For persistence pairs type networks, for each vertex representing an extremum  (i.e. minima and maxima), the index of the vertex that corresponds to the other extremum into which it would be merged if its persistence pair was canceled (indices start at 0). This can be used to reconstruct the tree of the hierarchy of maxima and minima. The value is -1 for non extrema critical points. The difference between the two versions is that the second (<em>parent_log_index</em>) is the hierarchy computed from the logarithm of the field. The second version is useful only for discrete point samples whose MS-complex is obtained from the delaunay tessellation computed with <em><a href="index490e.html?post/Usage">delaunay_nD</a></em>.  Practically, <em>parent_log_index</em> can be used whenever persistence pairs are cancelled in order of increasing ratio (option <em><a href="index4656.html?post/mse#nsig">-nsig</a></em> in <em>mse</em>), and <em>parent_index</em> whenever persistence pairs are cancelled in order of increasing difference  (option <em><a href="index4656.html?post/mse#cut">-cut</a></em> in <em>mse</em>).</li>
</ul>
<p><br /><a name="source"></a></p>
<ul>
<li>-<strong>source_cell</strong> / <strong>source_index</strong>:<br /> For networks representing manifolds (voids, walls, ... obtained with option <a href="index4656.html?post/mse#dumpmanifolds">-dumpManifolds</a> of mse), this represents for each simplex the critical point from which the manifold it belongs to originates (for instance, the minimum corresponding to a void, or the saddle point corresponding to a filament). In <em>source_cell</em>, the critical points is represented by its cell in the initial cell complex (see <strong>cell</strong> above), while <em>source_index</em> gives the index of the critical point in the <a href="index661f.html?post/skeleton-formats">skeleton</a> file or persistence pair network obtained with <a href="index4656.html?post/mse">mse</a> (options <em><a href="index4656.html?post/mse#dumparcs">-dumpArcs</a></em> and <em><a href="index4656.html?post/mse#ppairs">-ppairs</a></em>). See also <a href="index2d20.html?post/Example-1#voids">here</a> and <a href="indexf6f1.html?post/Example-2#walls">there</a> in the tutorial section.</li>
</ul></div>

    
                        </div>
    
      
    <div id="p30" class="post  " lang="en" xml:lang="en">

<!-- 
    <p class="day-date">Thursday, January  1 2426</p>  -->  
<!-- 
    <b1>&rsaquo;<a href="http://localhost/dotclear/index.php?post/NDnet-format">NDnet format</a></b1>
 -->  

    <h2 class="post-title"></br>&rsaquo;<a
    href="indexceff.html?post/NDnet-format">NDnet format</a></h2>

    <!-- 
    <p class="post-info">By thierry sousbie    on Thursday, January  1 2426, 13:14</p>
     -->  
    
    
    <!--
        -->

    <!--
          <div class="post-content"><p>This is the native binary format of DisPerSE. Functions for reading and writing <em>NDnet</em> format  in <em>C</em> can be found within the file <code>${DISPERSE_SRC}/src/C/NDnetwork.c</code> (see functions <em>Load_NDnetwork</em> and <em>Save_NDnetwork</em>). The format may seem relatively complex, but most of it is actually optional and not used in disperse (only simplicial complexes are used in DisPerSE). To create DisPerSE input files, it is only necessary to define the highest dimensional n-simplices as a list of (n+1) vertices (see also function <em>CreateNetwork</em>).
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="/dotclear/index.php?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).
<br />
<ins>Warning</ins>: in the following, for legacy reasons, the terms <em>n-face</em> and <em>n-cell</em> are used indifferently to designate polygons of dimension <em>n</em> (which are always simplexes in DisPerSE).
<br />
<br />
When using the C functions from Disperse, data is loaded into the following <em>C</em> structure which is close to the actual structure of the file (see file <code>${DISPERSE_SRC}/src/C/NDnetwork.h</code>):</p>

<pre>typedef struct
 {
   int type; // the cell-type
   char name[255];  // name of the field
   double *data;  // value for each of the nfaces[n] n-cells
} NDnetwork_Data;</pre>


<pre>// NDnetwork_SupData is not used in disperse ...
typedef struct
{
   int type; 
   char name[255];
   int datasize;
   char datatype[255];// a string to identity how data should be casted
   void *data;
} NDnetwork_SupData;</pre>


<pre>typedef struct 
{
   char comment[80];
   int periodicity;
   int ndims; // the number of spatial dimensions
   int ndims_net; // number of dimension of the network itself (e.g. 2 for a sphere embedded in 3D)
   int isSimpComplex;  // 1 if network is a simplicial complex (always true in disperse)
   double *x0;  // origin of the bounding box
   double *delta;  // size of the bounding box
   int indexSize; // size of NDNET_UINT type in Bytes
   int cumIndexSize; // size of NDNET_IDCUMT type in Bytes
   char dummy[160-4*2]; // dummy data reserved for future extensions
 
   NDNET_UINT nvertex;  // total number of vertices
   float *v_coord; //vertices coodinates (X_0,Y_0,Z_0,X_1,Y_1,...,Z_nvertex-1)
   
   NDNET_UINT *nfaces; // number of cells of a given type t is given by nfaces[t]
 
   int *haveVertexFromFace; // haveVertexFromFace[n] is 1 if we have an explicit definition of the n-cells (at least one type of cell must be defined).
   NDNET_IDCUMT **f_numVertexIndexCum;// cumulative number of vertice in the t-cells, NULL when cells are simplexes (isSimpComplex=1)
   NDNET_UINT **f_vertexIndex; // list of vertices defining the n-cells is stored in f_vertexIndex[n], all vertices being enumerated for each cell (the indices of the vertices in the kth n-cell start at f_vertexIndex[n][(n+1)*k] )
   // see also macro  NUM_VERTEX_IN_FACE(net,type,face) and VERTEX_IN_FACE(net,type,face)
 
   //This may be computed internally within DisPerSE but does not need to be defined explicitely
   int *haveFaceFromVertex; // haveFaceFromVertex[n] is 1 if we have an explicit list of all the n-cells that contain each vertex (used to navigate within the network)
   NDNET_IDCUMT **v_numFaceIndexCum; // cumulative number of t-cells a vertex v belongs to
   NDNET_UINT **v_faceIndex; // indices of the t-cells in the co-boundary of v ( the list of n-cells of vertex k starts at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k]] and ends at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k+1]] )
   // see also macro  NUM_FACE_IN_VERTEX(net,type,vertex) and  FACE_IN_VERTEX(net,type,vertex)
   
   // This can become extremely memory heavy ... NOT used in DisPerSE
   int **haveFaceFromFace; // haveFaceFromFace[k][n] is 1 if we have an explicit list of all the n-cells that have a boundary/co-boundary relation with each k-cell (used to navigate within the network)
   NDNET_IDCUMT ***f_numFaceIndexCum; //  cumulative number of n-cells having a boundary / co-boundary relation with each k-cell: f_numFaceIndexCum[k][n]
   NDNET_UINT ***f_faceIndex; // indices of the cells (similar to v_faceIndex)
   // see also macro NUM_FACE_IN_FACE(net,ref_type,ref_face,type) and FACE_IN_FACE(net,ref_type,ref_face,type)
   
   int haveVFlags;  // do we have flags associated to each vertex ?
   int *haveFFlags;  // do we have flags associated to each n-cell ?
   unsigned char *v_flag; // nvertex flag values (1 for each vertex) or NULL 
   unsigned char **f_flag; // nfaces[n] flag values (1 of each n-cell) or NULL

   int ndata; // number of additional data fields.
   NDnetwork_Data *data; // array of all additionnal data (data in total)
   
   int nsupData;
   NDnetwork_SupData *supData;

} NDnetwork;</pre>

<p><br />
<br />
The <em>NDnet</em> binary format is organized as follows (blocks are delimited by <em>dummy</em> variables indicating the size of the blocks for FORTRAN compatibility, but they are ignored in C):
<br />
<br /></p>
<table style="margin: 1em auto 1em auto"><caption>NDnet binary format</caption><tr  valign="top"><td width="10%">field</td><td width="10%">type</td><td width="10%">size</td><td width="65%">comment</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> for FORTRAN compatibility</td></tr>
<tr  valign="top"><td>tag</td><td>char(1B)</td><td>16</td><td>identifies the file type. Value : "NDNETWORK"</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndims</td><td>int(4B)</td><td>1</td><td>number of dimensions of the embedding space</td></tr>
<tr  valign="top"><td>ndims_net</td><td>int(4B)</td><td>1</td><td>ndims spanned by the network (=ndims by default)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>comment</td><td>char(1B)</td><td>80</td><td>a comment on the file (string)</td></tr>
<tr  valign="top"><td> periodicity</td><td>int(4B)</td><td>1</td><td> 0=non periodic, if p^th bit is set, boundary are periodic along dimension p</td></tr>
<tr  valign="top"><td>isSimpComplex</td><td>int(4B)</td><td>1</td><td> 1 if network is made of simplices (must be 1 for DisPerSE)</td></tr>
<tr  valign="top"><td>x0</td><td>double(8B)</td><td>ndims</td><td>origin of bounding box</td></tr>
<tr  valign="top"><td>delta</td><td>double(8B)</td><td>ndims</td><td>size of bounding box</td></tr>
<tr  valign="top"><td>index_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_UINT integer format in Bytes</td></tr>
<tr  valign="top"><td>cumindex_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_IDCUMT integer format in Bytes</td></tr>
<tr  valign="top"><td>dummy_ext</td><td>char(1B)</td><td>152</td><td>dummy data reserved for future extensions</td></tr>
<tr  valign="top"><td>nvertex</td><td>NDNET_UINT</td><td>1</td><td>number of vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>v_coords</td><td>float(4B)</td><td>ndims&timesnvertex</td><td>coordinates of the vertices [X0,Y0, ...]</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>nfaces</td><td>NDNET_UINT</td><td>ndims+1</td><td>number of cells of each type (N0,N1,...)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVertexFromFace</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 3 lines are repeated for each (ndims+1) possible cells type , only if haveVertexFromFace[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_vertexIndex[n]</td><td>NDNET_UINT</td><td>(n+1)&timesnfaces[n]</td><td style="background:lightblue">list of (n+1) vertex indices for each n-cell</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromVertex</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells in the co-boundary of each vertex explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 6 lines are repeated for each (ndims+1) possible cells type, only if haveFaceFromVertex[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>numFaceIndexCum[n]</td><td>NDNET_IDCUMT</td><td>nvertex+1</td><td style="background:lightblue">cumulative count of n-cells on vertices co-boundary</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_faceIndex[n]</td><td>NDNET_UINT</td><td>numFaceIndexCum[n]</td><td style="background:lightblue">list of n-cells on the co-boundary of each vertex (vertex i have numFaceIndexCum[n][i+1]-numFaceIndexCum[n][i] of them)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromFace</td><td>int(4B)</td><td>(ndims+1)^2</td><td>are n-cells in the co-boundary of each k-cell explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> This section describes boundary relation between n-cells and k-cells. It is usually empty in DisPerSE (see NDnetwork.c for details) so SKIP IT :)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVFlags</td><td>int(4B)</td><td>1</td><td> 1 if vertex flags are defined</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are skipped if haveVFlags=0</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_flag</td><td>uchar(1B)</td><td>nvertex</td><td style="background:lightblue"> value of the flags for vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFFlags</td><td>int(4B)</td><td>ndims+1</td><td> 1 if flags are defined for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are repeated for each n-cell such that haveFFlags[n]=1</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_flag[n]</td><td>uchar(1B)</td><td>nfaces[n]</td><td style="background:lightblue"> value of the flags for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndata</td><td>int(4B)</td><td>1</td><td> total number of additional fields</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 7 lines are repeated for each additional field (&timesndata)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>type</td><td>int(4B)</td><td>1</td><td style="background:lightblue"> the type of cells (0=vertex, n = n-simplex)</td></tr>
<tr  valign="top"><td>name</td><td>char(1B)</td><td>255</td><td style="background:lightblue"> name of the supplementary data</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>data</td><td>double(8B)</td><td>N</td><td style="background:lightblue"> data associated to cells or vertices. N is nfaces[n] or nvertex depending on the type value.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
</table></div>
        -->
    <div class="post-content"><p>This is the native binary format of DisPerSE. Functions for reading and writing <em>NDnet</em> format  in <em>C</em> can be found within the file <code>${DISPERSE_SRC}/src/C/NDnetwork.c</code> (see functions <em>Load_NDnetwork</em> and <em>Save_NDnetwork</em>). The format may seem relatively complex, but most of it is actually optional and not used in disperse (only simplicial complexes are used in DisPerSE). To create DisPerSE input files, it is only necessary to define the highest dimensional n-simplices as a list of (n+1) vertices (see also function <em>CreateNetwork</em>).
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="index4656.html?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).
<br />
<ins>Warning</ins>: in the following, for legacy reasons, the terms <em>n-face</em> and <em>n-cell</em> are used indifferently to designate polygons of dimension <em>n</em> (which are always simplexes in DisPerSE).
<br />
<br />
When using the C functions from Disperse, data is loaded into the following <em>C</em> structure which is close to the actual structure of the file (see file <code>${DISPERSE_SRC}/src/C/NDnetwork.h</code>):</p>

<pre>typedef struct
 {
   int type; // the cell-type
   char name[255];  // name of the field
   double *data;  // value for each of the nfaces[n] n-cells
} NDnetwork_Data;</pre>


<pre>// NDnetwork_SupData is not used in disperse ...
typedef struct
{
   int type; 
   char name[255];
   int datasize;
   char datatype[255];// a string to identity how data should be casted
   void *data;
} NDnetwork_SupData;</pre>


<pre>typedef struct 
{
   char comment[80];
   int periodicity;
   int ndims; // the number of spatial dimensions
   int ndims_net; // number of dimension of the network itself (e.g. 2 for a sphere embedded in 3D)
   int isSimpComplex;  // 1 if network is a simplicial complex (always true in disperse)
   double *x0;  // origin of the bounding box
   double *delta;  // size of the bounding box
   int indexSize; // size of NDNET_UINT type in Bytes
   int cumIndexSize; // size of NDNET_IDCUMT type in Bytes
   char dummy[160-4*2]; // dummy data reserved for future extensions
 
   NDNET_UINT nvertex;  // total number of vertices
   float *v_coord; //vertices coodinates (X_0,Y_0,Z_0,X_1,Y_1,...,Z_nvertex-1)
   
   NDNET_UINT *nfaces; // number of cells of a given type t is given by nfaces[t]
 
   int *haveVertexFromFace; // haveVertexFromFace[n] is 1 if we have an explicit definition of the n-cells (at least one type of cell must be defined).
   NDNET_IDCUMT **f_numVertexIndexCum;// cumulative number of vertice in the t-cells, NULL when cells are simplexes (isSimpComplex=1)
   NDNET_UINT **f_vertexIndex; // list of vertices defining the n-cells is stored in f_vertexIndex[n], all vertices being enumerated for each cell (the indices of the vertices in the kth n-cell start at f_vertexIndex[n][(n+1)*k] )
   // see also macro  NUM_VERTEX_IN_FACE(net,type,face) and VERTEX_IN_FACE(net,type,face)
 
   //This may be computed internally within DisPerSE but does not need to be defined explicitely
   int *haveFaceFromVertex; // haveFaceFromVertex[n] is 1 if we have an explicit list of all the n-cells that contain each vertex (used to navigate within the network)
   NDNET_IDCUMT **v_numFaceIndexCum; // cumulative number of t-cells a vertex v belongs to
   NDNET_UINT **v_faceIndex; // indices of the t-cells in the co-boundary of v ( the list of n-cells of vertex k starts at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k]] and ends at v_faceIndex[n][net-&gt;v_numFaceIndexCum[n][k+1]] )
   // see also macro  NUM_FACE_IN_VERTEX(net,type,vertex) and  FACE_IN_VERTEX(net,type,vertex)
   
   // This can become extremely memory heavy ... NOT used in DisPerSE
   int **haveFaceFromFace; // haveFaceFromFace[k][n] is 1 if we have an explicit list of all the n-cells that have a boundary/co-boundary relation with each k-cell (used to navigate within the network)
   NDNET_IDCUMT ***f_numFaceIndexCum; //  cumulative number of n-cells having a boundary / co-boundary relation with each k-cell: f_numFaceIndexCum[k][n]
   NDNET_UINT ***f_faceIndex; // indices of the cells (similar to v_faceIndex)
   // see also macro NUM_FACE_IN_FACE(net,ref_type,ref_face,type) and FACE_IN_FACE(net,ref_type,ref_face,type)
   
   int haveVFlags;  // do we have flags associated to each vertex ?
   int *haveFFlags;  // do we have flags associated to each n-cell ?
   unsigned char *v_flag; // nvertex flag values (1 for each vertex) or NULL 
   unsigned char **f_flag; // nfaces[n] flag values (1 of each n-cell) or NULL

   int ndata; // number of additional data fields.
   NDnetwork_Data *data; // array of all additionnal data (data in total)
   
   int nsupData;
   NDnetwork_SupData *supData;

} NDnetwork;</pre>

<p><br />
<br />
The <em>NDnet</em> binary format is organized as follows (blocks are delimited by <em>dummy</em> variables indicating the size of the blocks for FORTRAN compatibility, but they are ignored in C):
<br />
<br /></p>
<table style="margin: 1em auto 1em auto"><caption>NDnet binary format</caption><tr  valign="top"><td width="10%">field</td><td width="10%">type</td><td width="10%">size</td><td width="65%">comment</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"> for FORTRAN compatibility</td></tr>
<tr  valign="top"><td>tag</td><td>char(1B)</td><td>16</td><td>identifies the file type. Value : "NDNETWORK"</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndims</td><td>int(4B)</td><td>1</td><td>number of dimensions of the embedding space</td></tr>
<tr  valign="top"><td>ndims_net</td><td>int(4B)</td><td>1</td><td>ndims spanned by the network (=ndims by default)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>comment</td><td>char(1B)</td><td>80</td><td>a comment on the file (string)</td></tr>
<tr  valign="top"><td> periodicity</td><td>int(4B)</td><td>1</td><td> 0=non periodic, if p^th bit is set, boundary are periodic along dimension p</td></tr>
<tr  valign="top"><td>isSimpComplex</td><td>int(4B)</td><td>1</td><td> 1 if network is made of simplices (must be 1 for DisPerSE)</td></tr>
<tr  valign="top"><td>x0</td><td>double(8B)</td><td>ndims</td><td>origin of bounding box</td></tr>
<tr  valign="top"><td>delta</td><td>double(8B)</td><td>ndims</td><td>size of bounding box</td></tr>
<tr  valign="top"><td>index_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_UINT integer format in Bytes</td></tr>
<tr  valign="top"><td>cumindex_size</td><td>int(4B)</td><td>1</td><td>size of NDNET_IDCUMT integer format in Bytes</td></tr>
<tr  valign="top"><td>dummy_ext</td><td>char(1B)</td><td>152</td><td>dummy data reserved for future extensions</td></tr>
<tr  valign="top"><td>nvertex</td><td>NDNET_UINT</td><td>1</td><td>number of vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>v_coords</td><td>float(4B)</td><td>ndims&timesnvertex</td><td>coordinates of the vertices [X0,Y0, ...]</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>nfaces</td><td>NDNET_UINT</td><td>ndims+1</td><td>number of cells of each type (N0,N1,...)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVertexFromFace</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 3 lines are repeated for each (ndims+1) possible cells type , only if haveVertexFromFace[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_vertexIndex[n]</td><td>NDNET_UINT</td><td>(n+1)&timesnfaces[n]</td><td style="background:lightblue">list of (n+1) vertex indices for each n-cell</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromVertex</td><td>int(4B)</td><td>ndims+1</td><td>are n-cells in the co-boundary of each vertex explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:grey">*</td><td style="background:red"> next 6 lines are repeated for each (ndims+1) possible cells type, only if haveFaceFromVertex[n] is true.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>numFaceIndexCum[n]</td><td>NDNET_IDCUMT</td><td>nvertex+1</td><td style="background:lightblue">cumulative count of n-cells on vertices co-boundary</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_faceIndex[n]</td><td>NDNET_UINT</td><td>numFaceIndexCum[n]</td><td style="background:lightblue">list of n-cells on the co-boundary of each vertex (vertex i have numFaceIndexCum[n][i+1]-numFaceIndexCum[n][i] of them)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFaceFromFace</td><td>int(4B)</td><td>(ndims+1)^2</td><td>are n-cells in the co-boundary of each k-cell explicitly defined ? (0=no, 1=yes)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> This section describes boundary relation between n-cells and k-cells. It is usually empty in DisPerSE (see NDnetwork.c for details) so SKIP IT :)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveVFlags</td><td>int(4B)</td><td>1</td><td> 1 if vertex flags are defined</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are skipped if haveVFlags=0</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>v_flag</td><td>uchar(1B)</td><td>nvertex</td><td style="background:lightblue"> value of the flags for vertices</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>haveFFlags</td><td>int(4B)</td><td>ndims+1</td><td> 1 if flags are defined for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 3 lines are repeated for each n-cell such that haveFFlags[n]=1</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>f_flag[n]</td><td>uchar(1B)</td><td>nfaces[n]</td><td style="background:lightblue"> value of the flags for n-cells</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>ndata</td><td>int(4B)</td><td>1</td><td> total number of additional fields</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:grey"></td></tr>
<tr  valign="top"><td>*</td><td>*</td><td>*</td><td style="background:red"> next 7 lines are repeated for each additional field (&timesndata)</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>type</td><td>int(4B)</td><td>1</td><td style="background:lightblue"> the type of cells (0=vertex, n = n-simplex)</td></tr>
<tr  valign="top"><td>name</td><td>char(1B)</td><td>255</td><td style="background:lightblue"> name of the supplementary data</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
<tr  valign="top"><td>data</td><td>double(8B)</td><td>N</td><td style="background:lightblue"> data associated to cells or vertices. N is nfaces[n] or nvertex depending on the type value.</td></tr>
<tr  valign="top"><td style="background:grey">dummy</td><td style="background:grey">int(4B) </td><td style="background:grey">1</td><td style="background:lightblue"></td></tr>
</table></div>

    
                        </div>
    
      
    <div id="p31" class="post odd " lang="en" xml:lang="en">

<!-- 
    <p class="day-date">Friday, January  2 2426</p>  -->  
<!-- 
    <b1>&rsaquo;<a href="http://localhost/dotclear/index.php?post/NDnet_ascii-format">NDnet_ascii format</a></b1>
 -->  

    <h2 class="post-title"></br>&rsaquo;<a
    href="indexd2e2.html?post/NDnet_ascii-format">NDnet_ascii format</a></h2>

    <!-- 
    <p class="post-info">By thierry sousbie    on Friday, January  2 2426, 13:14</p>
     -->  
    
    
    <!--
        -->

    <!--
          <div class="post-content"><p>This ASCII format is a simpler version of the <a href="/dotclear/index.php?post/NDnet-format">NDnet</a> format, designed to be fully compatible but restricted to simplicial networks. It is easy to read and write and should probably be used for reasonably sized data sets.
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="/dotclear/index.php?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).</p>


<p><br />
<br /></p>
<table border="1"><caption> NDnet_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> ANDNET</th><td> header</td></tr>
<tr  valign="top"><th> ndims</th><td> the number of dimensions</td></tr>
<tr  valign="top"><th> #comments go here</th><td> OPTIONAL: should start with '#' if present (the 80 first characters are read and stored).</td></tr>
<tr  valign="top"><th> BBOX [x0_1 .. x0_d] [delta_1 .. delta_d]</th><td> OPTIONAL: the bounding box, defined by the 'ndims' coordinates of the origin 'x0' and extent 'delta'.</td></tr>
<tr  valign="top"><th> nv</th><td> number of vertices</td></tr>
<tr  valign="top"><th> vx[0] vy[0] ...</th><td> the ndims coordinates of the first vertex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each vertex</td></tr>
<tr  valign="top"><td style="background:red" colspan="2" >Simplices definition (0-cells up to ndims-cells). One blue block should be added for each type of explicitly defined simplex. Note that only the highest dimension cells are sufficient to define a complex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> T N</th><td style="background:lightblue"> network has N T-simplices (each T-simplex has (T+1) vertices).</td></tr>
<tr  valign="top"><th style="background:lightblue"> i[0] j[0] ...</th><td style="background:lightblue"> the T+1 indices (start at 0) of the vertices of the first T-simplex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> ...</th><td style="background:lightblue"> one line for each of the N T-simplices</td></tr>
<tr  valign="top"><th> [ADDITIONAL_DATA]</th><td> OPTIONAL: indicate the beginning of the additional data section</td></tr>
<tr  valign="top"><th> additional_data_name_1</th><td> name of the additional data (e.g. field_value for mse input files)</td></tr>
<tr  valign="top"><th> T</th><td> type of simplex it is associated to (T-simplex, 0 means vertices)</td></tr>
<tr  valign="top"><th> val[0]</th><td> value for the first T-simplex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each T-simplex</td></tr>
</table></div>
        -->
    <div class="post-content"><p>This ASCII format is a simpler version of the <a href="indexceff.html?post/NDnet-format">NDnet</a> format, designed to be fully compatible but restricted to simplicial networks. It is easy to read and write and should probably be used for reasonably sized data sets.
<br />
<br />
<ins>Note</ins>: The scalar function whose MS-complex is computed by <a href="index4656.html?post/mse">mse</a> can be stored as an additional data field
named 'field_value' (case sensitive).</p>


<p><br />
<br /></p>
<table border="1"><caption> NDnet_ascii format</caption><tr ><td  width="50%" ></td><td  width="50%" ></td></tr>
<tr  valign="top"><th> ANDNET</th><td> header</td></tr>
<tr  valign="top"><th> ndims</th><td> the number of dimensions</td></tr>
<tr  valign="top"><th> #comments go here</th><td> OPTIONAL: should start with '#' if present (the 80 first characters are read and stored).</td></tr>
<tr  valign="top"><th> BBOX [x0_1 .. x0_d] [delta_1 .. delta_d]</th><td> OPTIONAL: the bounding box, defined by the 'ndims' coordinates of the origin 'x0' and extent 'delta'.</td></tr>
<tr  valign="top"><th> nv</th><td> number of vertices</td></tr>
<tr  valign="top"><th> vx[0] vy[0] ...</th><td> the ndims coordinates of the first vertex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each vertex</td></tr>
<tr  valign="top"><td style="background:red" colspan="2" >Simplices definition (0-cells up to ndims-cells). One blue block should be added for each type of explicitly defined simplex. Note that only the highest dimension cells are sufficient to define a complex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> T N</th><td style="background:lightblue"> network has N T-simplices (each T-simplex has (T+1) vertices).</td></tr>
<tr  valign="top"><th style="background:lightblue"> i[0] j[0] ...</th><td style="background:lightblue"> the T+1 indices (start at 0) of the vertices of the first T-simplex.</td></tr>
<tr  valign="top"><th style="background:lightblue"> ...</th><td style="background:lightblue"> one line for each of the N T-simplices</td></tr>
<tr  valign="top"><th> [ADDITIONAL_DATA]</th><td> OPTIONAL: indicate the beginning of the additional data section</td></tr>
<tr  valign="top"><th> additional_data_name_1</th><td> name of the additional data (e.g. field_value for mse input files)</td></tr>
<tr  valign="top"><th> T</th><td> type of simplex it is associated to (T-simplex, 0 means vertices)</td></tr>
<tr  valign="top"><th> val[0]</th><td> value for the first T-simplex</td></tr>
<tr  valign="top"><th> ...</th><td> One line for each T-simplex</td></tr>
</table></div>

    
                        </div>
    
      
    <div id="p32" class="post  " lang="en" xml:lang="en">

<!-- 
    <p class="day-date">Saturday, January  3 2426</p>  -->  
<!-- 
    <b1>&rsaquo;<a href="http://localhost/dotclear/index.php?post/ply-format">ply format</a></b1>
 -->  

    <h2 class="post-title"></br>&rsaquo;<a
    href="indexda8a.html?post/ply-format">ply format</a></h2>

    <!-- 
    <p class="post-info">By thierry sousbie    on Saturday, January  3 2426, 13:14</p>
     -->  
    
    
    <!--
        -->

    <!--
          <div class="post-content"><p>The PLY format is a relatively generic file format designed to store three dimensional data from 3D scanners with the possibility of associating properties to the polygons. Information on this format can be found on <a href="http://en.wikipedia.org/wiki/PLY_(file_format)" title="PLY format">wikipedia</a>  (see also the <em>External links</em> section). A very efficient C library for reading and writing PLY files in ASCII or binary format is <a href="http://w3.impa.br/~diego/software/rply/" title="RPly">RPly</a> (DisPerSE uses it for PLY files I/O, see files <em>NDnet_PLY_IO.c</em> and <em>NDnet_PLY_IO.h</em>).
<br />
<br />
A typical header for a PLY file readable by <a href="/dotclear/index.php?post/netconv">netconv</a> or <a href="/dotclear/index.php?post/mse">mse</a> is as follows:</p>


<pre>ply
format ascii 1.0
element bbox 1
property list uchar double x0 
property list uchar double delta
element vertex 77595
property float x
property float y
property float z
property double field_value
element face 482867
property list uchar uint vertex_indices
end_header</pre>

<p><br />
<br /></p>
<ul>
<li>-<strong>format</strong> may be ASCII or little / big endian binary</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>bbox</strong> element is used to define a bounding box if available (x0 is its origin and delta its extent)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>coordinates</strong> of the vertices are given as vertex properties labeled <em>x</em>, <em>y</em>, and <em>z</em> or <em>x0</em>, <em>x1</em>, ... (the number of this properties gives the dimension of the embedding space)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>faces</strong> are defined by the property vertex_indices, each element corresponding to a list of vertices. A cell is always supposed to be a simplex, so the number of vertices determine the dimension spanned by the complex (a 2D complex may be embedded in a 3D space).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>additional properties</strong> may be defined for cells and vertices. In particular, a  vertex property labeled <em>field_value</em> would be used as input function in <a href="/dotclear/index.php?post/mse">mse</a>.</li>
</ul></div>
        -->
    <div class="post-content"><p>The PLY format is a relatively generic file format designed to store three dimensional data from 3D scanners with the possibility of associating properties to the polygons. Information on this format can be found on <a href="http://en.wikipedia.org/wiki/PLY_(file_format)" title="PLY format">wikipedia</a>  (see also the <em>External links</em> section). A very efficient C library for reading and writing PLY files in ASCII or binary format is <a href="http://w3.impa.br/~diego/software/rply/" title="RPly">RPly</a> (DisPerSE uses it for PLY files I/O, see files <em>NDnet_PLY_IO.c</em> and <em>NDnet_PLY_IO.h</em>).
<br />
<br />
A typical header for a PLY file readable by <a href="index25e8.html?post/netconv">netconv</a> or <a href="index4656.html?post/mse">mse</a> is as follows:</p>


<pre>ply
format ascii 1.0
element bbox 1
property list uchar double x0 
property list uchar double delta
element vertex 77595
property float x
property float y
property float z
property double field_value
element face 482867
property list uchar uint vertex_indices
end_header</pre>

<p><br />
<br /></p>
<ul>
<li>-<strong>format</strong> may be ASCII or little / big endian binary</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>bbox</strong> element is used to define a bounding box if available (x0 is its origin and delta its extent)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>coordinates</strong> of the vertices are given as vertex properties labeled <em>x</em>, <em>y</em>, and <em>z</em> or <em>x0</em>, <em>x1</em>, ... (the number of this properties gives the dimension of the embedding space)</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>faces</strong> are defined by the property vertex_indices, each element corresponding to a list of vertices. A cell is always supposed to be a simplex, so the number of vertices determine the dimension spanned by the complex (a 2D complex may be embedded in a 3D space).</li>
</ul>
<p><br /></p>
<ul>
<li>-<strong>additional properties</strong> may be defined for cells and vertices. In particular, a  vertex property labeled <em>field_value</em> would be used as input function in <a href="index4656.html?post/mse">mse</a>.</li>
</ul></div>

    
                        </div>
    
      
    <div id="p33" class="post odd " lang="en" xml:lang="en">

<!-- 
    <p class="day-date">Sunday, January  4 2426</p>  -->  
<!-- 
    <b1>&rsaquo;<a href="http://localhost/dotclear/index.php?post/vtk-network-format">vtk network format</a></b1>
 -->  

    <h2 class="post-title"></br>&rsaquo;<a
    href="indexe8f9.html?post/vtk-network-format">vtk network format</a></h2>

    <!-- 
    <p class="post-info">By thierry sousbie    on Sunday, January  4 2426, 13:14</p>
     -->  
    
    
    <!--
        -->

    <!--
          <div class="post-content"><p>VTK formats are developed for the Visualization Tool Kit library (<a href="/dotclear/index.php?post/vtk-formats">VTK</a>) and can be used for 3D visualization with software such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a>. Networks are stored as <em>VTK unstructured network data</em> and can be output in fours different VTK formats:
<br /><br /></p>
<ul>
<li>-<strong>vtk</strong>: the legacy format</li>
<li>-<strong>vtk_ascii</strong>: ASCII version of the vtk format</li>
<li>-<strong>vtu</strong>: a more recently developed XML version of the vtk format,</li>
<li>-<strong>vtu_ascii</strong>: ASCII version of the vtu format</li>
</ul>
<p><br />
<br />
The specifications for these formats can be found in this <a href="www.vtk.org/VTK/img/file-formats.pdf" title="VTK formats PDF">PDF</a> file. See also <a href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a> and <a href="http://mathema.tician.de/node/430" title="there">there</a> for additional information.
<br />
<br />
<br />
<br />
<br /></p></div>
        -->
    <div class="post-content"><p>VTK formats are developed for the Visualization Tool Kit library (<a href="indexb3eb.html?post/vtk-formats">VTK</a>) and can be used for 3D visualization with software such as <a href="https://wci.llnl.gov/codes/visit/">VisIt</a> or <a href="http://www.paraview.org/">ParaView</a>. Networks are stored as <em>VTK unstructured network data</em> and can be output in fours different VTK formats:
<br /><br /></p>
<ul>
<li>-<strong>vtk</strong>: the legacy format</li>
<li>-<strong>vtk_ascii</strong>: ASCII version of the vtk format</li>
<li>-<strong>vtu</strong>: a more recently developed XML version of the vtk format,</li>
<li>-<strong>vtu_ascii</strong>: ASCII version of the vtu format</li>
</ul>
<p><br />
<br />
The specifications for these formats can be found in this <a href="file-formats.html" title="VTK formats PDF">PDF</a> file. See also <a href="http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html">here</a> and <a href="http://mathema.tician.de/node/430" title="there">there</a> for additional information.
<br />
<br />
<br />
<br />
<br /></p></div>

    
                        </div>
    
                  </div>
</div> <!-- End #main -->

<div id="sidebar">
  <div id="blognav">
    <div class="categories"><ul><li><a href="index1694.html?category/Download">Download</a></li><li><a href="indexba87.html?category/Install">Install</a></li><li><a href="index3c4a.html?category/Overview">Overview</a></li><li><a href="index4559.html?category/Terminology">Terminology</a></li><li><a href="index4f3e.html?category/Manual">Manual</a></li><li><a href="index55a0.html?category/Quick-start">Tutorial</a></li><li><a href="index3333.html?category/Skeleton-I-O">Skeleton data</a></li><li class="category-current"><a href="indexe2a5.html?category/Network-I-O">Network data</a></li><li><a href="indexc777.html?category/Field-I-O">Field data</a></li><li><a href="indexdc31.html?category/References">Contact &amp; References</a></li></ul></div>  </div> <!-- End #blognav -->
  ____________________
 
  <div id="blogextra">
        Network data</br>
  
          <a href="index9cca.html?post/networks">&#187; Network files</a></br>
          <a href="indexceff.html?post/NDnet-format">&#187; NDnet format</a></br>
          <a href="indexd2e2.html?post/NDnet_ascii-format">&#187; NDnet_ascii format</a></br>
          <a href="indexda8a.html?post/ply-format">&#187; ply format</a></br>
          <a href="indexe8f9.html?post/vtk-network-format">&#187; vtk network format</a></br>
      
  </div> <!-- End #blogextra -->

</div>

</div> <!-- End #wrapper -->

<div id="footer">
  <p>Powered by <a href="http://www.dotclear.net/">DotClear</a> - Contact: sousbie<em>(AT)</em>iap<em>.</em>fr . </p>
</div>
</div> <!-- End #page -->
</body>

<!-- Mirrored from localhost/dotclear/index.php?category/Network-I-O by HTTrack Website Copier/3.x [XR&CO'2010], Sun, 27 Jan 2013 10:35:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>
